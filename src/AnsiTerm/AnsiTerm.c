/* Generated by wbuild from "AnsiTerm.w"
** (generator version $Revision$ of $Date$)
*/
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#line 1734 "AnsiTerm.w"
#include <assert.h>
#line 1735 "AnsiTerm.w"
#include <stdio.h>
#line 1736 "AnsiTerm.w"
#include <X11/Xatom.h>
#line 1737 "AnsiTerm.w"
#include <X11/keysym.h>
#line 1738 "AnsiTerm.w"
#include <X11/Xmu/Xmu.h>
#include <Xfwf/AnsiTermP.h>
#line 840 "AnsiTerm.w"
static void key(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 887 "AnsiTerm.w"
static void start_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 904 "AnsiTerm.w"
static void extend_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 966 "AnsiTerm.w"
static void end_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 1027 "AnsiTerm.w"
static void paste_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);

static XtActionsRec actionsList[] = {
{"key", key},
{"start_selection", start_selection},
{"extend_selection", extend_selection},
{"end_selection", end_selection},
{"paste_selection", paste_selection},
};

static char defaultTranslations[] = "\
Shift<Btn1Down>: extend_selection() \n\
<Btn1Down>: start_selection() traverseCurrent() \n\
<Btn1Motion>: extend_selection() \n\
<Btn1Up>: end_selection() \n\
<Btn2Down>: paste_selection() \n\
<Map>: traverseCurrent() \n\
";
static void _resolve_inheritance(
#if NeedFunctionPrototypes
WidgetClass
#endif
);
#line 292 "AnsiTerm.w"
static void initialize(
#if NeedFunctionPrototypes
Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 344 "AnsiTerm.w"
static Boolean  set_values(
#if NeedFunctionPrototypes
Widget ,Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 401 "AnsiTerm.w"
static XtGeometryResult  query_geometry(
#if NeedFunctionPrototypes
Widget,XtWidgetGeometry *,XtWidgetGeometry *
#endif
);
#line 425 "AnsiTerm.w"
static void realize(
#if NeedFunctionPrototypes
Widget,XtValueMask *,XSetWindowAttributes *
#endif
);
#line 436 "AnsiTerm.w"
static void resize(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 446 "AnsiTerm.w"
static void destroy(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 476 "AnsiTerm.w"
static void expose(
#if NeedFunctionPrototypes
Widget,XEvent *,Region 
#endif
);
#line 527 "AnsiTerm.w"
static void scroll_response(
#if NeedFunctionPrototypes
Widget ,XtPointer ,XtPointer 
#endif
);
#line 633 "AnsiTerm.w"
static void write(
#if NeedFunctionPrototypes
Widget,char *,int 
#endif
);
#line 1036 "AnsiTerm.w"
#define max(a, b) ((a )>(b )?(a ):(b ))


#line 1037 "AnsiTerm.w"
#define min(a, b) ((a )<(b )?(a ):(b ))


#line 1043 "AnsiTerm.w"
static void draw_line(
#if NeedFunctionPrototypes
Widget,int ,int ,int ,int 
#endif
);
#line 1081 "AnsiTerm.w"
static Boolean  convert_proc(
#if NeedFunctionPrototypes
Widget,Atom *,Atom *,Atom *,XtPointer *,unsigned  long *,int *
#endif
);
#line 1126 "AnsiTerm.w"
static void lose_ownership_proc(
#if NeedFunctionPrototypes
Widget,Atom *
#endif
);
#line 1133 "AnsiTerm.w"
static void paste_callback(
#if NeedFunctionPrototypes
Widget,XtPointer ,Atom *,Atom *,XtPointer ,unsigned  long *,int *
#endif
);
#line 1153 "AnsiTerm.w"
static void compute_cell_size(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1176 "AnsiTerm.w"
static int  compute_framewd(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1191 "AnsiTerm.w"
#define myrealloc(p, n) ((XtPointer )XtRealloc ((XtPointer )(p ),(n )*sizeof (*(p ))))


#line 1193 "AnsiTerm.w"
static void allocate_contents(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1233 "AnsiTerm.w"
static void toggle_cursor(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1251 "AnsiTerm.w"
static void blink_handler(
#if NeedFunctionPrototypes
XtPointer ,XtIntervalId *
#endif
);
#line 1269 "AnsiTerm.w"
static void map_handler(
#if NeedFunctionPrototypes
Widget,XtPointer ,XEvent *,Boolean *
#endif
);
#line 1282 "AnsiTerm.w"
static void send_scroll_notify(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1305 "AnsiTerm.w"
static void clip_gcs(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1320 "AnsiTerm.w"
static void make_gc(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1373 "AnsiTerm.w"
static void add_char(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1399 "AnsiTerm.w"
static void repeat_char(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1409 "AnsiTerm.w"
static void next_tabstop(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1427 "AnsiTerm.w"
static void delete_line(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1449 "AnsiTerm.w"
static void cursor_down(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1466 "AnsiTerm.w"
static void clear_eol(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1478 "AnsiTerm.w"
static void clear_eos(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1497 "AnsiTerm.w"
static void delete_char(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1511 "AnsiTerm.w"
static void insert_chars(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1528 "AnsiTerm.w"
static void insert_line(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1551 "AnsiTerm.w"
static void set_attrib(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1572 "AnsiTerm.w"
static void memory_lock(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1577 "AnsiTerm.w"
static void memory_unlock(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1585 "AnsiTerm.w"
static void goto_xy(
#if NeedFunctionPrototypes
Widget,int ,int 
#endif
);
#line 1596 "AnsiTerm.w"
static void report_cursor_pos(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1610 "AnsiTerm.w"
static void find_cell(
#if NeedFunctionPrototypes
Widget,int ,int ,int ,int *,int *
#endif
);
#line 1631 "AnsiTerm.w"
#define F_FOUNDRY 1 


#line 1632 "AnsiTerm.w"
#define F_FAMILY 2 


#line 1633 "AnsiTerm.w"
#define F_WEIGHT 3 


#line 1634 "AnsiTerm.w"
#define F_SLANT 4 


#line 1635 "AnsiTerm.w"
#define F_SET_WIDTH 5 


#line 1636 "AnsiTerm.w"
#define F_SANS 6 


#line 1637 "AnsiTerm.w"
#define F_PIXELS 7 


#line 1638 "AnsiTerm.w"
#define F_POINTS 8 


#line 1639 "AnsiTerm.w"
#define F_HRESOLUTION 9 


#line 1640 "AnsiTerm.w"
#define F_VRESOLUTION 10 


#line 1641 "AnsiTerm.w"
#define F_SPACING 11 


#line 1642 "AnsiTerm.w"
#define F_AVG_WITH 12 


#line 1643 "AnsiTerm.w"
#define F_CHARSET 13 


#line 1645 "AnsiTerm.w"
static Boolean  parse_font_name(
#if NeedFunctionPrototypes
String ,String *
#endif
);
#line 1667 "AnsiTerm.w"
static void infer_bold(
#if NeedFunctionPrototypes
Widget,int ,XrmValue *
#endif
);
#line 1700 "AnsiTerm.w"
static void handle_keys(
#if NeedFunctionPrototypes
Widget,XtPointer ,XEvent *,Boolean *
#endif
);
#line 1043 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1043 "AnsiTerm.w"
static void draw_line(Widget self,int  framewd,int  row,int  lft,int  rgt)
#else
#line 1043 "AnsiTerm.w"
static void draw_line(self,framewd,row,lft,rgt)Widget self;int  framewd;int  row;int  lft;int  rgt;
#endif
#line 1044 "AnsiTerm.w"
{
    Display *dpy = XtDisplay(self);
    Window win = XtWindow(self);
    int x, y, i, n;
    GC use_gc;

    x = framewd + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + lft * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset;
    y = framewd + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + row * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->ascent - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset;
    while (lft < rgt) {
	i = lft + 1;
	while (i < rgt && ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[row][i] == ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[row][lft]) i++;
        if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[row][lft] & ATTRIB_INVIS) {
            XClearArea(dpy, win, x, y - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->ascent, n * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth,
		       ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight, FALSE);
        } else {
	    switch (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[row][lft] & (ATTRIB_REV | ATTRIB_BOLD)) {
	    case 0: use_gc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc; break;
	    case ATTRIB_BOLD: use_gc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc; break;
	    case ATTRIB_REV: use_gc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc; break;
	    case ATTRIB_REV | ATTRIB_BOLD: use_gc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc; break;
	    }
	    n = i - lft;
	    XDrawImageString(dpy, win, use_gc, x, y, &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[row][lft], n);
	    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[row][lft] & ATTRIB_ULINE)
		XDrawLine(dpy, win, use_gc, x, y + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_pos,
			  x + n * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth, y + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_pos);
	}
	lft = i;
	x += n * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth;
    }
}
#line 1081 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1081 "AnsiTerm.w"
static Boolean  convert_proc(Widget self,Atom * selection,Atom * target,Atom * type_return,XtPointer * value_return,unsigned  long * length_return,int * format_return)
#else
#line 1081 "AnsiTerm.w"
static Boolean  convert_proc(self,selection,target,type_return,value_return,length_return,format_return)Widget self;Atom * selection;Atom * target;Atom * type_return;XtPointer * value_return;unsigned  long * length_return;int * format_return;
#endif
#line 1082 "AnsiTerm.w"
{
    if (*target == XA_TARGETS(XtDisplay(self))) {

	XSelectionRequestEvent *req;
	Atom *targetP;
	Atom *std_targets;
	unsigned long std_length;

	req = XtGetSelectionRequest(self, *selection, NULL);
	XmuConvertStandardSelection(self, req->time, selection, target,
	    type_return, (XtPointer *) &std_targets, &std_length,
	    format_return);
	*value_return = XtMalloc(sizeof(Atom) * (std_length + 1));
	targetP = *(Atom **) value_return;
	*length_return = std_length + 1;
	*targetP++ = XA_STRING;
	bcopy((char*)std_targets, (char*)targetP, sizeof(Atom) * std_length);
	XtFree((char *) std_targets);
	*type_return = XA_ATOM;
	*format_return = sizeof(Atom) * 8;
	return TRUE;

    } else if (*target == XA_STRING) {
	*value_return = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection;
	*type_return = XA_STRING;
	*length_return = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection_len;
	*format_return = 8;
	return TRUE;
	
    } else {

	if (XmuConvertStandardSelection(self, CurrentTime, selection, target,
		type_return, value_return, length_return, format_return))
	    return TRUE;
	else
	    return FALSE;
    }
}
#line 1126 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1126 "AnsiTerm.w"
static void lose_ownership_proc(Widget self,Atom * selection)
#else
#line 1126 "AnsiTerm.w"
static void lose_ownership_proc(self,selection)Widget self;Atom * selection;
#endif
#line 1127 "AnsiTerm.w"
{}
#line 1133 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1133 "AnsiTerm.w"
static void paste_callback(Widget self,XtPointer  client_data,Atom * selection,Atom * type,XtPointer  value,unsigned  long * length,int * format)
#else
#line 1133 "AnsiTerm.w"
static void paste_callback(self,client_data,selection,type,value,length,format)Widget self;XtPointer  client_data;Atom * selection;Atom * type;XtPointer  value;unsigned  long * length;int * format;
#endif
#line 1134 "AnsiTerm.w"
{
    char *text = (char *) value;
    int i;

    assert(*selection == XA_PRIMARY && *type == XA_STRING && *format == 8);

    if (value == NULL && *length == 0) {
	XBell(XtDisplay(self), 0);
	return;
    }
    for (i = 0; i < *length; i++)
	XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.keyCallback, (XtPointer) &text[i]);
    XtFree(value);
}
#line 1153 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1153 "AnsiTerm.w"
static void compute_cell_size(Widget self)
#else
#line 1153 "AnsiTerm.w"
static void compute_cell_size(self)Widget self;
#endif
#line 1154 "AnsiTerm.w"
{
    unsigned long h1, h2;

    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt, XA_QUAD_WIDTH, &h1))
	h1 = XTextWidth(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt, "M", 1);
    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont, XA_QUAD_WIDTH, &h2))
	h2 = XTextWidth(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont, "M", 1);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth = max(h1, h2);

    h1 = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->ascent + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->descent;
    h2 = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont->ascent + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont->descent;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight = max(h1, h2);

    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt, XA_UNDERLINE_POSITION, &h1)) h1 = 2;
    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont, XA_UNDERLINE_POSITION, &h2)) h2 = 2;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_pos = max(h1, h2);

    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt, XA_UNDERLINE_THICKNESS, &h1)) h1 = 1;
    if (! XGetFontProperty(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont, XA_UNDERLINE_THICKNESS, &h2)) h2 = 1;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_thick = max(h1, h2);
}
#line 1176 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1176 "AnsiTerm.w"
static int  compute_framewd(Widget self)
#else
#line 1176 "AnsiTerm.w"
static int  compute_framewd(self)Widget self;
#endif
#line 1177 "AnsiTerm.w"
{
    Position x, y;
    Dimension w, h;

    ((XfwfAnsiTermWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, &x, &y, &w, &h);
    return x;
}
#line 1193 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1193 "AnsiTerm.w"
static void allocate_contents(Widget self)
#else
#line 1193 "AnsiTerm.w"
static void allocate_contents(self)Widget self;
#endif
#line 1194 "AnsiTerm.w"
{
    int i, j;

    /* Remove superfluous lines */
    for (i = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows; i++) {
	XtFree(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i]);
	XtFree(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i]);
    }
    /* Allocate and initialize new lines */
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents = myrealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs = myrealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows);
    for (i = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows; i++) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i] = XtMalloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i] = XtMalloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
	for (j = 0; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) {
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i][j] = ' ';
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] = 0;
	}
    }
    /* Lengthen or shorten existing lines */
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_columns != ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns) {
	for (i = 0; i < min(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows); i++) {
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i] = myrealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i], ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i] = myrealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i], ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
	    for (j = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_columns; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) {
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i][j] = ' ';
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] = 0;
	    }
	}
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_columns = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns;
}
#line 1233 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1233 "AnsiTerm.w"
static void toggle_cursor(Widget self)
#else
#line 1233 "AnsiTerm.w"
static void toggle_cursor(self)Widget self;
#endif
#line 1234 "AnsiTerm.w"
{
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursor_on) {				/* Restore to normal */
	draw_line(self, compute_framewd(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.old_cy, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.old_cx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.old_cx + 1);
    } else if (! ((XfwfAnsiTermWidget)self)->xfwfCommon.traversalOn || ((XfwfAnsiTermWidget)self)->xfwfCommon.traversal_focus) { /* Draw in reverse */
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] ^= ATTRIB_REV;
	draw_line(self, compute_framewd(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx + 1);
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] ^= ATTRIB_REV;
    } else {					/* Draw with underline */
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] ^= ATTRIB_ULINE;
	draw_line(self, compute_framewd(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx + 1);
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] ^= ATTRIB_ULINE;
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.old_cx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.old_cy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursor_on = ! ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursor_on;
}
#line 1251 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1251 "AnsiTerm.w"
static void blink_handler(XtPointer  client_data,XtIntervalId * id)
#else
#line 1251 "AnsiTerm.w"
static void blink_handler(client_data,id)XtPointer  client_data;XtIntervalId * id;
#endif
#line 1252 "AnsiTerm.w"
{
    Widget self = (Widget) client_data;
    toggle_cursor(self);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
			     500, blink_handler, self);
}
#line 1269 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1269 "AnsiTerm.w"
static void map_handler(Widget self,XtPointer  client_data,XEvent * event,Boolean * cont)
#else
#line 1269 "AnsiTerm.w"
static void map_handler(self,client_data,event,cont)Widget self;XtPointer  client_data;XEvent * event;Boolean * cont;
#endif
#line 1270 "AnsiTerm.w"
{
    if (event->type == MapNotify)
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
				 500, blink_handler, self);
    else if (event->type == UnmapNotify)
	XtRemoveTimeOut(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.timer);
}
#line 1282 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1282 "AnsiTerm.w"
static void send_scroll_notify(Widget self)
#else
#line 1282 "AnsiTerm.w"
static void send_scroll_notify(self)Widget self;
#endif
#line 1283 "AnsiTerm.w"
{
    int framewd, width, height, desiredwd, desiredht;
    XfwfScrollInfo info;

    framewd = compute_framewd(self);
    width = ((XfwfAnsiTermWidget)self)->core.width - 2 * framewd;
    height = ((XfwfAnsiTermWidget)self)->core.height - 2 * framewd;
    desiredwd = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth;
    desiredht = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight;

    info.reason = XfwfSNotify;
    info.flags = XFWF_VPOS | XFWF_VSIZE | XFWF_HPOS | XFWF_HSIZE;
    info.hpos = width<desiredwd ? (float)((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset/(desiredwd - width) : 0.0;
    info.vpos = height<desiredht ? (float)((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset/(desiredht - height) : 0.0;
    info.hsize = width < desiredwd ? (float)width/desiredwd : 1.0;
    info.vsize = height < desiredht ? (float)height/desiredht : 1.0;
    XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollCallback, &info);
}
#line 1305 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1305 "AnsiTerm.w"
static void clip_gcs(Widget self)
#else
#line 1305 "AnsiTerm.w"
static void clip_gcs(self)Widget self;
#endif
#line 1306 "AnsiTerm.w"
{
    XRectangle rect;
    ((XfwfAnsiTermWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, &rect.x, &rect.y, &rect.width, &rect.height);
    XSetClipRectangles(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc, 0, 0, &rect, 1, YXSorted);
    XSetClipRectangles(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc, 0, 0, &rect, 1, YXSorted);
    XSetClipRectangles(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc, 0, 0, &rect, 1, YXSorted);
    XSetClipRectangles(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc, 0, 0, &rect, 1, YXSorted);
}
#line 1320 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1320 "AnsiTerm.w"
static void make_gc(Widget self)
#else
#line 1320 "AnsiTerm.w"
static void make_gc(self)Widget self;
#endif
#line 1321 "AnsiTerm.w"
{
    XGCValues values;
    XtGCMask mask, dynmask, dontmask;

    mask = GCFont | GCForeground | GCBackground | GCLineWidth;
    dynmask = GCClipMask;
    dontmask = GCArcMode | GCDashOffset | GCDashList | GCFillRule |
	GCFillStyle | GCJoinStyle | GCStipple | GCFillRule | GCTile |
	GCTileStipXOrigin | GCTileStipYOrigin;

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc) XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc);
    values.font = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->fid;
    values.foreground = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.foreground;
    values.background = ((XfwfAnsiTermWidget)self)->core.background_pixel;
    values.line_width = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_thick;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc) XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc);
    values.font = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont->fid;
    values.foreground = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.foreground;
    values.background = ((XfwfAnsiTermWidget)self)->core.background_pixel;
    values.line_width = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_thick;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc) XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc);
    values.font = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt->fid;
    values.foreground = ((XfwfAnsiTermWidget)self)->core.background_pixel;
    values.background = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.foreground;
    values.line_width = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_thick;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc) XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc);
    values.font = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont->fid;
    values.foreground = ((XfwfAnsiTermWidget)self)->core.background_pixel;
    values.background = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.foreground;
    values.line_width = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.uline_thick;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    clip_gcs(self);
}
#line 1373 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1373 "AnsiTerm.w"
static void add_char(Widget self,int  c)
#else
#line 1373 "AnsiTerm.w"
static void add_char(self,c)Widget self;int  c;
#endif
#line 1374 "AnsiTerm.w"
{
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.insert_mode) {
        memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+1],
                &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - 1);
        memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+1],
                &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - 1);
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] = c;
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib;
    } else {
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] = c;
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib;
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1)
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx++;
    else {					/* Margin reached */
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = 0;				/* CR */
        cursor_down(self);				/* LF */
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.last_char = c;				/* Save for repeat_char() */
}
#line 1399 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1399 "AnsiTerm.w"
static void repeat_char(Widget self,int  n)
#else
#line 1399 "AnsiTerm.w"
static void repeat_char(self,n)Widget self;int  n;
#endif
#line 1400 "AnsiTerm.w"
{
    for (; n > 0; n--) add_char(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.last_char);
}
#line 1409 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1409 "AnsiTerm.w"
static void next_tabstop(Widget self)
#else
#line 1409 "AnsiTerm.w"
static void next_tabstop(self)Widget self;
#endif
#line 1410 "AnsiTerm.w"
{
    if (! ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.insert_mode) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = ((((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx + 8)/8) * 8;
    } else {
	int x = ((((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx + 8)/8) * 8;
	if (x >= ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns) x = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1;
	while (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx != x) add_char(self, ' ');
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
    }
}
#line 1427 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1427 "AnsiTerm.w"
static void delete_line(Widget self)
#else
#line 1427 "AnsiTerm.w"
static void delete_line(self)Widget self;
#endif
#line 1428 "AnsiTerm.w"
{
    int i;
    char *swap_contents, *swap_attribs;

    swap_contents = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory];
    swap_attribs = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory];
    for (i = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1; i++) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i+1];
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i+1];
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][0] |= ATTRIB_DIRTY;
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1] = swap_contents;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1] = swap_attribs;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1][0] |= ATTRIB_DIRTY;
    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1][0], ' ', ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1][0], 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
}
#line 1449 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1449 "AnsiTerm.w"
static void cursor_down(Widget self)
#else
#line 1449 "AnsiTerm.w"
static void cursor_down(self)Widget self;
#endif
#line 1450 "AnsiTerm.w"
{
    int framewd, save_y;
    
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1)
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory++;
    else {
	save_y = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.locked_lines;
	delete_line(self);
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = save_y;
    }
}
#line 1466 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1466 "AnsiTerm.w"
static void clear_eol(Widget self)
#else
#line 1466 "AnsiTerm.w"
static void clear_eol(self)Widget self;
#endif
#line 1467 "AnsiTerm.w"
{
    int framewd = compute_framewd(self);

    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], ' ', ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx);
    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1478 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1478 "AnsiTerm.w"
static void clear_eos(Widget self)
#else
#line 1478 "AnsiTerm.w"
static void clear_eos(self)Widget self;
#endif
#line 1479 "AnsiTerm.w"
{
    int i, save_x, save_y;

    clear_eol(self);
    save_x = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx;
    save_y = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = 0;
    for (i = save_y + 1; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows; i++) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = i;
	clear_eol(self);
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = save_x;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = save_y;
}
#line 1497 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1497 "AnsiTerm.w"
static void delete_char(Widget self)
#else
#line 1497 "AnsiTerm.w"
static void delete_char(self)Widget self;
#endif
#line 1498 "AnsiTerm.w"
{
    memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+1],
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - 1);
    memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+1],
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - 1);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns-1] = ' ';
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns-1] = 0;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1511 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1511 "AnsiTerm.w"
static void insert_chars(Widget self,int  n)
#else
#line 1511 "AnsiTerm.w"
static void insert_chars(self,n)Widget self;int  n;
#endif
#line 1512 "AnsiTerm.w"
{
    if (n > ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx) n = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx;
    memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+n], &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx],
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - n);
    memmove(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx+n], &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx],
	    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx - n);
    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], ' ', n);
    memset(&((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx], 0, n);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1528 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1528 "AnsiTerm.w"
static void insert_line(Widget self)
#else
#line 1528 "AnsiTerm.w"
static void insert_line(self)Widget self;
#endif
#line 1529 "AnsiTerm.w"
{
    int framewd, i;
    char *swap_contents, *swap_attribs;

    swap_contents = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1];
    swap_attribs = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows-1];
    for (i = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1; i > ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory; i--) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i-1];
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i-1];
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][0] |= ATTRIB_DIRTY;
    }
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory] = swap_contents;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory] = swap_attribs;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
    memset(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory], ' ', ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
    memset(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory], 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
}
#line 1551 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1551 "AnsiTerm.w"
static void set_attrib(Widget self,int  n)
#else
#line 1551 "AnsiTerm.w"
static void set_attrib(self,n)Widget self;int  n;
#endif
#line 1552 "AnsiTerm.w"
{
    int i;

    for (i = 0; i < n; i++) {
	switch(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[i]) {
	case 0: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib = 0; break;
	case 1: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib |= ATTRIB_BOLD; break;
	case 4: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib |= ATTRIB_ULINE; break;
	case 5: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib |= ATTRIB_BOLD; break; /* Should be: blinking */
	case 7: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib |= ATTRIB_REV; break;
        case 8: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib |= ATTRIB_INVIS; break;
	}
    }
}
#line 1572 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1572 "AnsiTerm.w"
static void memory_lock(Widget self)
#else
#line 1572 "AnsiTerm.w"
static void memory_lock(self)Widget self;
#endif
#line 1573 "AnsiTerm.w"
{
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.locked_lines = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;                  /* Lock lines above cursor */
}
#line 1577 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1577 "AnsiTerm.w"
static void memory_unlock(Widget self)
#else
#line 1577 "AnsiTerm.w"
static void memory_unlock(self)Widget self;
#endif
#line 1578 "AnsiTerm.w"
{
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.locked_lines = 0;
}
#line 1585 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1585 "AnsiTerm.w"
static void goto_xy(Widget self,int  x,int  y)
#else
#line 1585 "AnsiTerm.w"
static void goto_xy(self,x,y)Widget self;int  x;int  y;
#endif
#line 1586 "AnsiTerm.w"
{
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = max(0, min(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1, x));
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = max(0, min(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1, y));
}
#line 1596 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1596 "AnsiTerm.w"
static void report_cursor_pos(Widget self)
#else
#line 1596 "AnsiTerm.w"
static void report_cursor_pos(self)Widget self;
#endif
#line 1597 "AnsiTerm.w"
{
    char s[25];
    int i, n;

    n = sprintf(s, "\033[%d;%dR", ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory + 1, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx + 1);
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.keyCallback, &s[i]);
}
#line 1610 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1610 "AnsiTerm.w"
static void find_cell(Widget self,int  framewd,int  cx,int  cy,int * col,int * row)
#else
#line 1610 "AnsiTerm.w"
static void find_cell(self,framewd,cx,cy,col,row)Widget self;int  framewd;int  cx;int  cy;int * col;int * row;
#endif
#line 1611 "AnsiTerm.w"
{
    int i, j, x, y;

    for (x = framewd + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth, i = 0;
	i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1 && x < cx;
	i++, x += ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth) ;

    for (y = framewd + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight, j = 0;
	j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1 && y < cy;
	j++, y += ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight) ;

    *col = i;
    *row = j;
}
#line 1645 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1645 "AnsiTerm.w"
static Boolean  parse_font_name(String  name,String * table)
#else
#line 1645 "AnsiTerm.w"
static Boolean  parse_font_name(name,table)String  name;String * table;
#endif
#line 1646 "AnsiTerm.w"
{
    int i, field;

    if (name == NULL || name[0] != '-') return False;
    table[0] = XtNewString(name);
    for (i = field = 0; name[i] != '\0'; i++) {
	if (name[i] == '-') {
	    field++;
	    table[0][i] = '\0';
	    table[field] = &table[0][i+1];
	    if (field == 13) break;		/* No more fields */
	}
    }
    return True;
}
#line 1667 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1667 "AnsiTerm.w"
static void infer_bold(Widget self,int  offset,XrmValue * value)
#else
#line 1667 "AnsiTerm.w"
static void infer_bold(self,offset,value)Widget self;int  offset;XrmValue * value;
#endif
#line 1668 "AnsiTerm.w"
{
    static XFontStruct *fs = NULL;
    String info[15];
    char s[250];

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font == NULL)
	XtAppError(XtWidgetToApplicationContext(self),
		   "Font resource may not be NULL in AnsiTerm widget");

    if (parse_font_name(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font, info)) {
	sprintf(s, "-%s-%s-%s-%s-*-%s-*-%s-%s-%s-%s-*-%s",
		info[F_FOUNDRY], info[F_FAMILY], "bold",
		info[F_SLANT], /* info[F_SET_WIDTH], */ info[F_SANS],
		/* info[F_PIXELS], */ info[F_POINTS], info[F_HRESOLUTION],
		info[F_VRESOLUTION], info[F_SPACING],
		/* info[F_AVG_WIDTH], */ info[F_CHARSET]);
	fs = XLoadQueryFont(XtDisplay(self), s);
    }
    if (! fs)					/* Try font unchanged */
	fs = XLoadQueryFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font);
    if (! fs)
	XtAppWarning(XtWidgetToApplicationContext(self),
		   "Couldn't find font for AnsiTerm widget");
    value->addr = (XtPointer) &fs;
}
#line 1700 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1700 "AnsiTerm.w"
static void handle_keys(Widget self,XtPointer  client_data,XEvent * event,Boolean * cont)
#else
#line 1700 "AnsiTerm.w"
static void handle_keys(self,client_data,event,cont)Widget self;XtPointer  client_data;XEvent * event;Boolean * cont;
#endif
#line 1701 "AnsiTerm.w"
{
    char buf[15];
    KeySym keysym;
    int n, i;
    
    assert(event->type == KeyPress);

    n = XLookupString(&event->xkey, buf, sizeof(buf), &keysym, NULL);
    if (n == 0)
	switch (keysym) {
	case XK_BackSpace:  n = 1; buf[0] = '\010';	    break;
	case XK_Home:	    n = 3; strcpy(buf, "\033[H");   break;
	case XK_Down:	    n = 3; strcpy(buf, "\033[B");   break;
	case XK_Left:	    n = 3; strcpy(buf, "\033[D");   break;
	case XK_Right:	    n = 3; strcpy(buf, "\033[C");   break;
	case XK_Up:	    n = 3; strcpy(buf, "\033[A");   break;
	case XK_Return:
	case XK_KP_Enter:
	case XK_Linefeed:   n = 1; buf[0] = '\015';	    break;
	case XK_Tab:	    n = 1; buf[0] = '\011';	    break;
	case XK_Delete:     n = 1; buf[0] = '\177';	    break;
	default:
	    if ((event->xkey.state & ControlMask)
		&& 65 <= keysym && keysym <= 95)
		buf[n++] = keysym - 64;	/* Control + letter */
	}
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.keyCallback, &buf[i]);
    if (n != 0) *cont = FALSE;
}

static XtResource resources[] = {
#line 34 "AnsiTerm.w"
{XtNrows,XtCRows,XtRInt,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.rows),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.rows),XtRImmediate,(XtPointer)24 },
#line 41 "AnsiTerm.w"
{XtNcolumns,XtCColumns,XtRInt,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.columns),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.columns),XtRImmediate,(XtPointer)80 },
#line 48 "AnsiTerm.w"
{XtNfont,XtCFont,XtRString,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.font),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.font),XtRImmediate,(XtPointer)XtDefaultFont },
#line 53 "AnsiTerm.w"
{XtNboldfont,XtCBoldfont,XtRXFontStruct,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.boldfont),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.boldfont),XtRCallProc,(XtPointer)infer_bold },
#line 57 "AnsiTerm.w"
{XtNmargin,XtCMargin,XtRInt,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.margin),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.margin),XtRImmediate,(XtPointer)10 },
#line 61 "AnsiTerm.w"
{XtNforeground,XtCForeground,XtRPixel,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.foreground),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.foreground),XtRString,(XtPointer)XtDefaultForeground },
#line 69 "AnsiTerm.w"
{XtNkeyCallback,XtCKeyCallback,XtRCallback,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.keyCallback),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.keyCallback),XtRImmediate,(XtPointer)NULL },
#line 77 "AnsiTerm.w"
{XtNresizeCallback,XtCResizeCallback,XtRCallback,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.resizeCallback),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.resizeCallback),XtRImmediate,(XtPointer)NULL },
#line 96 "AnsiTerm.w"
{XtNscrollCallback,XtCScrollCallback,XtRCallback,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.scrollCallback),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.scrollCallback),XtRImmediate,(XtPointer)NULL },
#line 103 "AnsiTerm.w"
{XtNscrollResponse,XtCScrollResponse,XtRXTCallbackProc,sizeof(((XfwfAnsiTermRec*)NULL)->xfwfAnsiTerm.scrollResponse),XtOffsetOf(XfwfAnsiTermRec,xfwfAnsiTerm.scrollResponse),XtRImmediate,(XtPointer)scroll_response ;},
};

XfwfAnsiTermClassRec xfwfAnsiTermClassRec = {
{ /* core_class part */
/* superclass   	*/  (WidgetClass) &xfwfBoardClassRec,
/* class_name   	*/  "XfwfAnsiTerm",
/* widget_size  	*/  sizeof(XfwfAnsiTermRec),
/* class_initialize 	*/  NULL,
/* class_part_initialize*/  _resolve_inheritance,
/* class_inited 	*/  FALSE,
/* initialize   	*/  initialize,
/* initialize_hook 	*/  NULL,
/* realize      	*/  realize,
/* actions      	*/  actionsList,
/* num_actions  	*/  5,
/* resources    	*/  resources,
/* num_resources 	*/  10,
/* xrm_class    	*/  NULLQUARK,
/* compres_motion 	*/  True ,
/* compress_exposure 	*/  XtExposeCompressMultiple |XtExposeGraphicsExpose |XtExposeGraphicsExposeMerged ,
/* compress_enterleave 	*/  True ,
/* visible_interest 	*/  TRUE ,
/* destroy      	*/  destroy,
/* resize       	*/  resize,
/* expose       	*/  expose,
/* set_values   	*/  set_values,
/* set_values_hook 	*/  NULL,
/* set_values_almost 	*/  XtInheritSetValuesAlmost,
/* get_values+hook 	*/  NULL,
/* accept_focus 	*/  XtInheritAcceptFocus,
/* version      	*/  XtVersion,
/* callback_private 	*/  NULL,
/* tm_table      	*/  defaultTranslations,
/* query_geometry 	*/  query_geometry,
/* display_acceleator 	*/  XtInheritDisplayAccelerator,
/* extension    	*/  NULL 
},
{ /* composite_class part */
XtInheritGeometryManager,
XtInheritChangeManaged,
XtInheritInsertChild,
XtInheritDeleteChild,
NULL
},
{ /* XfwfCommon_class part */
XtInherit_compute_inside,
XtInherit_total_frame_width,
XtInherit_highlight_border,
XtInherit_unhighlight_border,
XtInherit_would_accept_focus,
XtInherit_traverse,
XtInherit_lighter_color,
XtInherit_darker_color,
/* traversal_trans */  NULL ,
},
{ /* XfwfFrame_class part */
 /* dummy */  0
},
{ /* XfwfBoard_class part */
XtInherit_set_abs_location,
},
{ /* XfwfAnsiTerm_class part */
scroll_response,
write,
},
};
WidgetClass xfwfAnsiTermWidgetClass = (WidgetClass) &xfwfAnsiTermClassRec;
/*ARGSUSED*/
#line 840 "AnsiTerm.w"
static void key(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    char buf[15];
    KeySym keysym;
    int n, i;
    
    if (event->type != KeyPress && event->type != KeyRelease)
	XtError("key() action in AnsiTerm not associated with key events");

    n = XLookupString(&event->xkey, buf, sizeof(buf), &keysym, NULL);
    if (n == 0)
	switch (keysym) {
	case XK_BackSpace:  n = 1; buf[0] = '\010';	    break;
	case XK_Home:	    n = 3; strcpy(buf, "\033[H");   break;
	case XK_Down:	    n = 3; strcpy(buf, "\033[B");   break;
	case XK_Left:	    n = 3; strcpy(buf, "\033[D");   break;
	case XK_Right:	    n = 3; strcpy(buf, "\033[C");   break;
	case XK_Up:	    n = 3; strcpy(buf, "\033[A");   break;
	case XK_Return:
	case XK_KP_Enter:
	case XK_Linefeed:   n = 1; buf[0] = '\015';	    break;
	case XK_Tab:	    n = 1; buf[0] = '\011';	    break;
	case XK_Delete:     n = 1; buf[0] = '\177';	    break;
	default:
	    if ((event->xkey.state & ControlMask)
		&& 65 <= keysym && keysym <= 95) {
		buf[n++] = keysym - 64;	/* Control + letter */
	    }
	}
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.keyCallback, &buf[i]);
}

/*ARGSUSED*/
#line 887 "AnsiTerm.w"
static void start_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    find_cell(self, compute_framewd(self), event->xbutton.x + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset,
	      event->xbutton.y + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset, &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x, &((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y);
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_x = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.drag_started = FALSE;			/* No selection yet */
}

/*ARGSUSED*/
#line 904 "AnsiTerm.w"
static void extend_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    int i, j, framewd, sx, sy, ex, ey, x, y;

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.drag_started = TRUE;
    framewd = compute_framewd(self);
    find_cell(self, framewd, event->xbutton.x + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset,
	      event->xbutton.y + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset, &x, &y);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y < y
        || (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y == y && ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x < x)) {
        sy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y;  ey = y;
        sx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x;  ex = x;
    } else {                                   /* Swap start and end */
        sy = y;  ey = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y;
        sx = x;  ex = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x;
    }    

    /* Draw the lines that the mouse passed over since last event */
    for (i = min(y, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y); i <= max(y, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y); i++) {

        /* Toggle REV attribute on cells within selected region */
        if (i == sy && i == ey)
            for (j = sx; j <= ex; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == sy)
            for (j = sx; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == ey)
            for (j = 0; j < ex; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (sy < i && i < ey)
            for (j = 0; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;

        draw_line(self, framewd, i, 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);	/* Draw the line */

        /* Toggle REV attribute on cells in region again */
        if (i == sy && i == ey)
            for (j = sx; j <= ex; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == sy)
            for (j = sx; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == ey)
            for (j = 0; j < ex; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (sy < i && i < ey)
            for (j = 0; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
    }

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_x = x;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y = y;
}

/*ARGSUSED*/
#line 966 "AnsiTerm.w"
static void end_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    int sx, sy, ex, ey, k, i, j, framewd;

    if (! ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.drag_started) return;		/* No movement since BtnDown */

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y
        || (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y == ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y && ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_x)) {
        sy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y;  ey = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y;
        sx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x;  ex = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_x;
    } else {					/* Swap start & end */
        sy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_y;  ey = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_y;
        sx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.end_x;  ex = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.start_x;
    }

    /* Unhighlight the selection */
    framewd = compute_framewd(self);
    if (sy == ey) {
        draw_line(self, framewd, sy, sx, ex + 1);
    } else {
        draw_line(self, framewd, sy, sx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns); /* First (partial) line */
        for (i = sy + 1; i <= ey - 1; i++)      /* Middle lines */
            draw_line(self, framewd, i, 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
        draw_line(self, framewd, ey, 0, ex + 1);   /* Last (partial) line */
    }

    /* Copy selection to buffer */
    if (sy == ey) {

        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection = XtRealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection, ex - sx + 2);
        for (k = 0, j = sx; j <= ex; k++, j++)
            ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[sy][j];
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = '\0';
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection_len = k;

    } else {

        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection = XtRealloc(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection,
            ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - sx + 1 + (ey - sy - 1) * (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns + 1) + ex + 3);
        k = 0;
        for (j = sx; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++, k++)
            ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[sy][j];
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k++] = '\n';
        for (i = sy + 1; i <= ey - 1; i++) {
            for (j = 0; j < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns; j++, k++)
                ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i][j];
            ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k++] = '\n';
        }
        for (j = 0; j <= ex; j++, k++)
            ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[ey][j];
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection[k] = '\0';
        ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection_len = k;
    }

    /* Now ask the X server for ownership of the selection */
    if (XtOwnSelection(self, XA_PRIMARY, event->xbutton.time,
		       convert_proc, lose_ownership_proc, NULL) == FALSE)
        XtAppWarning(XtWidgetToApplicationContext(self),
		     "Failed to become selection owner");
}

/*ARGSUSED*/
#line 1027 "AnsiTerm.w"
static void paste_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    XtGetSelectionValue(self, XA_PRIMARY, XA_STRING, paste_callback, NULL,
	event->xbutton.time);
}

static void _resolve_inheritance(class)
WidgetClass class;
{
  XfwfAnsiTermWidgetClass c = (XfwfAnsiTermWidgetClass) class;
  XfwfAnsiTermWidgetClass super;
  static CompositeClassExtensionRec extension_rec = {
    NULL, NULLQUARK, XtCompositeExtensionVersion,
    sizeof(CompositeClassExtensionRec), True};
  CompositeClassExtensionRec *ext;
  ext = (XtPointer)XtMalloc(sizeof(*ext));
  *ext = extension_rec;
  ext->next_extension = c->composite_class.extension;
  c->composite_class.extension = ext;
  if (class == xfwfAnsiTermWidgetClass) return;
  super = (XfwfAnsiTermWidgetClass)class->core_class.superclass;
  if (c->xfwfAnsiTerm_class.scroll_response == XtInherit_scroll_response)
    c->xfwfAnsiTerm_class.scroll_response = super->xfwfAnsiTerm_class.scroll_response;
  if (c->xfwfAnsiTerm_class.write == XtInherit_write)
    c->xfwfAnsiTerm_class.write = super->xfwfAnsiTerm_class.write;
}
#line 292 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 292 "AnsiTerm.w"
static void initialize(Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 292 "AnsiTerm.w"
static void initialize(request,self,args,num_args)Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 293 "AnsiTerm.w"
{
    int framewd = 2 * compute_framewd(self);

    (void) XmuInternAtom(XtDisplay(self), XmuMakeAtom("NULL"));
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt = XLoadQueryFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font);
    if (! ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt)
	XtAppError(XtWidgetToApplicationContext(self),
		   "Failed to find font in AnsiTerm");
    compute_cell_size(self);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns < 1) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns = 1;
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows < 1) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows = 1;
    ((XfwfAnsiTermWidget)self)->core.width = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth;
    ((XfwfAnsiTermWidget)self)->core.height = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight;

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_columns = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows = 0;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs = NULL;
    allocate_contents(self);

    XtAddEventHandler(self, StructureNotifyMask, FALSE, map_handler, NULL);
    XtInsertEventHandler(self, KeyPressMask, FALSE, handle_keys, NULL,
			 XtListHead);

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc = NULL;
    make_gc(self);

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = 0;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursor_on = FALSE;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib = 0;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.insert_mode = FALSE;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.last_char = ' ';
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.selection = NULL;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.locked_lines = 0;

    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset = 0;
    ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset = 0;
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollResponse != scroll_response) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollResponse = scroll_response;
	XtAppWarning(XtWidgetToApplicationContext(self),
		     "scrollResponse resource may only be queried, not set");
    }
}
#line 344 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 344 "AnsiTerm.w"
static Boolean  set_values(Widget  old,Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 344 "AnsiTerm.w"
static Boolean  set_values(old,request,self,args,num_args)Widget  old;Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 345 "AnsiTerm.w"
{
    Bool redraw = FALSE, need_gc = FALSE;
    int framewd = 2 * compute_framewd(self);

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.font || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.boldfont) {
	if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt) XFreeFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt);
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt = XLoadQueryFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.font);
	need_gc = TRUE;
	compute_cell_size(self);
    }
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.foreground != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.foreground
	|| ((XfwfAnsiTermWidget)self)->core.background_pixel != ((XfwfAnsiTermWidget)old)->core.background_pixel) {
	need_gc = TRUE;
    }

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns < 1) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns = 1;		/* Silently increase */
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows < 1) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows = 1;

    if (((XfwfAnsiTermWidget)self)->core.width == ((XfwfAnsiTermWidget)old)->core.width) {
	/* If columns changed, but width didn't, recompute width */
	if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.columns
	    || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.margin || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.cellwidth)
	    ((XfwfAnsiTermWidget)self)->core.width = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth;
    }
    if (((XfwfAnsiTermWidget)self)->core.height == ((XfwfAnsiTermWidget)old)->core.height) {
	/* If rows changed, but height didn't, recompute height */
	if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.rows
	    || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.margin || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.cellheight)
	    ((XfwfAnsiTermWidget)self)->core.height = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight;
    }
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.rows || ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.columns)
	allocate_contents(self);
	
    if (need_gc) {
	make_gc(self);
	redraw = TRUE;
    }
    if (((XfwfAnsiTermWidget)self)->core.width != ((XfwfAnsiTermWidget)old)->core.width || ((XfwfAnsiTermWidget)self)->core.height != ((XfwfAnsiTermWidget)old)->core.height)
	redraw = FALSE;			/* Don't redraw if resizing */

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx >= ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1;
    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory >= ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows - 1;

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollResponse != ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.scrollResponse) {
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollResponse = ((XfwfAnsiTermWidget)old)->xfwfAnsiTerm.scrollResponse;
	XtAppWarning(XtWidgetToApplicationContext(self),
		     "scrollResponse resource may only be queried, not set");
    }

    return redraw;
}
#line 401 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 401 "AnsiTerm.w"
static XtGeometryResult  query_geometry(Widget self,XtWidgetGeometry * request,XtWidgetGeometry * reply)
#else
#line 401 "AnsiTerm.w"
static XtGeometryResult  query_geometry(self,request,reply)Widget self;XtWidgetGeometry * request;XtWidgetGeometry * reply;
#endif
#line 402 "AnsiTerm.w"
{
    int framewd = compute_framewd(self);

    /* Compute our preferred geometry */
    reply->request_mode = CWWidth | CWHeight;
    reply->width = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth;
    reply->height = framewd + 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight;

    if ((!(request->request_mode & CWWidth)
	 || request->width == reply->width)
	&& (!(request->request_mode & CWHeight)
	    || request->height == reply->height))
	return XtGeometryYes;			/* Accept the request */

    if (((XfwfAnsiTermWidget)self)->core.width == reply->width && ((XfwfAnsiTermWidget)self)->core.height == reply->height)
	return XtGeometryNo;			/* Ask for no change */

    return XtGeometryAlmost;			/* We supply an alternative */
}
#line 425 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 425 "AnsiTerm.w"
static void realize(Widget self,XtValueMask * mask,XSetWindowAttributes * attributes)
#else
#line 425 "AnsiTerm.w"
static void realize(self,mask,attributes)Widget self;XtValueMask * mask;XSetWindowAttributes * attributes;
#endif
#line 426 "AnsiTerm.w"
{
    xfwfBoardClassRec.core_class.realize(self, mask, attributes);
    send_scroll_notify(self);
}
#line 436 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 436 "AnsiTerm.w"
static void resize(Widget self)
#else
#line 436 "AnsiTerm.w"
static void resize(self)Widget self;
#endif
#line 437 "AnsiTerm.w"
{
    send_scroll_notify(self);
    clip_gcs(self);
}
#line 446 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 446 "AnsiTerm.w"
static void destroy(Widget self)
#else
#line 446 "AnsiTerm.w"
static void destroy(self)Widget self;
#endif
#line 447 "AnsiTerm.w"
{
    int i;

    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows != 0) {
	for (i = 0; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.allocated_rows; i++) {
	    XtFree(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents[i]);
	    XtFree(((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i]);
	}
	XtFree((char *) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.contents);
	XtFree((char *) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs);
    }
    XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc);
    XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc);
    XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc);
    XtReleaseGC(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc);
    XFreeFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.fnt);
    XFreeFont(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldfont);
}
#line 476 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 476 "AnsiTerm.w"
static void expose(Widget self,XEvent * event,Region  region)
#else
#line 476 "AnsiTerm.w"
static void expose(self,event,region)Widget self;XEvent * event;Region  region;
#endif
#line 477 "AnsiTerm.w"
{
    int top, bot, lft, rgt, framewd, y, x, i, w, h;
    XExposeEvent *ev = (XExposeEvent *) event;
    Region region1;
    XRectangle rect;

    if (! XtIsRealized(self)) return;

    xfwfBoardClassRec.core_class.expose(self, event, region);			/* Superclass draws frame */

    ((XfwfAnsiTermWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, &rect.x, &rect.y, &rect.width, &rect.height);
    framewd = rect.x;
    region1 = XCreateRegion();
    XUnionRectWithRegion(&rect, region1, region1);
    if (region) XIntersectRegion(region, region1, region1);
    XSetRegion(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc, region1);
    XSetRegion(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.boldgc, region1);
    XSetRegion(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revgc, region1);
    XSetRegion(XtDisplay(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.revboldgc, region1);

    x = ev ? ev->x + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset : ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset;
    y = ev ? ev->y + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset : ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset;
    w = ev ? ev->width : rect.width;
    h = ev ? ev->height : rect.height;

    find_cell(self, framewd, x, y, &lft, &top);
    find_cell(self, framewd, x + w, y + h, &rgt, &bot);

    if (lft < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns && top < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows)
	for (i = top; i <= bot; i++) draw_line(self, framewd, i, lft, rgt + 1);

    XDestroyRegion(region1);
    clip_gcs(self);				/* Reset clipping region */
}
#line 527 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 527 "AnsiTerm.w"
static void scroll_response(Widget  wdg,XtPointer  client_data,XtPointer  call_data)
#else
#line 527 "AnsiTerm.w"
static void scroll_response(wdg,client_data,call_data)Widget  wdg;XtPointer  client_data;XtPointer  call_data;
#endif
#line 528 "AnsiTerm.w"
{
    Widget self = (Widget) client_data;
    XfwfScrollInfo new, *info = (XfwfScrollInfo *) call_data;
    int maxx, maxy, desiredwd, desiredht, newx, newy;
    XRectangle rect;

    newx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset;				/* Will become new xoffset */
    newy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset;				/* Will become new yoffset */
    desiredwd = 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth; /* Virtual width */
    desiredht = 2 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.margin + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight; /* Virtual height */
    ((XfwfAnsiTermWidgetClass)self->core.widget_class)->xfwfCommon_class.compute_inside(self, &rect.x, &rect.y, &rect.width, &rect.height);
    maxx = max(0, desiredwd - rect.width);	/* Max. for xoffset */
    maxy = max(0, desiredht - rect.height);	/* Max. for yoffset */

    switch (info->reason) {
    case XfwfSUp:
	newy = max(0, newy - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight);
	info->flags |= XFWF_VPOS;
	info->vpos = maxy != 0 ? (float) newy/maxy : 0.0;
	break;
    case XfwfSPageUp:
	newy = max(0, newy - rect.height);
	info->flags |= XFWF_VPOS;
	info->vpos = maxy != 0 ? (float) newy/maxy : 0.0;
	break;
    case XfwfSDown:
	newy = min(maxy, newy + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellheight);
	info->flags |= XFWF_VPOS;
	info->vpos = maxy != 0 ? (float) newy/maxy : 0.0;
	break;
    case XfwfSPageDown:
	newy = min(maxy, newy + rect.height);
	info->flags |= XFWF_VPOS;
	info->vpos = maxy != 0 ? (float) newy/maxy : 0.0;
	break;
    case XfwfSLeft:
	newx = max(0, newx - ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth);
	info->flags |= XFWF_HPOS;
	info->hpos = maxx != 0 ? (float) newx/maxx : 0.0;
	break;
    case XfwfSPageLeft:
	newx = max(0, newx - rect.width);
	info->flags |= XFWF_HPOS;
	info->hpos = maxx != 0 ? (float) newx/maxx : 0.0;
	break;
    case XfwfSRight:
	newx = min(maxx, newx + ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cellwidth);
	info->flags |= XFWF_HPOS;
	info->hpos = maxx != 0 ? (float) newx/maxx : 0.0;
	break;
    case XfwfSPageRight:
	newx = min(maxx, newx + rect.width);
	info->flags |= XFWF_HPOS;
	info->hpos = maxx != 0 ? (float) newx/maxx : 0.0;
	break;
    case XfwfSDrag: case XfwfSMove:
	if (info->flags & XFWF_HPOS) newx = info->hpos * maxx;
	if (info->flags & XFWF_VPOS) newy = info->vpos * maxy;
	break;
    default:
	; /* skip */
    }
    if (newx != ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset || newy != ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset) {
	if (XtIsRealized(self)) {
#if 0
	    XCopyArea(XtDisplay(self), XtWindow(self), XtWindow(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.gc,
		      -((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset, -((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset, desiredwd, desiredht,
		      -newx, -newy);
#else
	    XClearArea(XtDisplay(self), XtWindow(self), rect.x, rect.y,
		       rect.width, rect.height, TRUE);
#endif
	}
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.xoffset = newx;
	((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.yoffset = newy;
    }

    /* Pass (updated) info on to others in scrolling chain */
    if (info->reason != XfwfSNotify) {
	new = *info;
	new.reason = XfwfSNotify;
	XtCallCallbackList(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.scrollCallback, &new);
    }
}
#line 633 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 633 "AnsiTerm.w"
static void write(Widget self,char * text,int  n)
#else
#line 633 "AnsiTerm.w"
static void write(self,text,n)Widget self;char * text;int  n;
#endif
#line 634 "AnsiTerm.w"
{
    int framewd, i;

    for (i = 0; i < n; i++) {
        switch (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state) {
        case Init:
            switch (text[i]) {
            case '\007': XBell(XtDisplay(self), 0); break; /* Bell */
            case '\015': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = 0; break;	/* CR */
            case '\011': next_tabstop(self); break; /* Tab */
            case '\012': cursor_down(self); break;	/* LF */
            case '\010': if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx--; break; /* Backspace */
            case '\033': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Esc; break;	/* Esc */
            default: add_char(self, text[i]);
            }
            break;
        case Esc:
            switch (text[i]) {
            case '[': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = EscLB; break;
	    case '2': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;	/* Set tab stop ignored */
	    case '7':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx;
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case '8': goto_xy(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedy); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
            default:                            /* Unrecognized sequence */
                add_char(self, '\033');
                add_char(self, text[i]);
                ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
            }
	    break;
	case EscLB:
	    switch (text[i]) {
	    case 'H': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'J': clear_eos(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'K': clear_eol(self), ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] = text[i] - '0';
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Register0;
		break;
	    case 'C': 
		if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns - 1) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx++;
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case 'A': if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory) ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory--; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'P': delete_char(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'M': delete_line(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'm': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cur_attrib = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case '@': insert_chars(self, 1); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'L': insert_line(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case '>': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = EscLBGT; break;
	    case 's':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx;
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedy = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory;
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case 'u': goto_xy(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedx, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.savedy); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'r': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default:				/* Unrecognized sequence */
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, text[i]);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
	    }
		break;
	case Register0:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] = 10 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] + text[i] - '0';
		break;
	    case ';': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[1] = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Register1; break;
	    case 'm': set_attrib(self, 1); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'h': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.insert_mode = TRUE; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'l': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.insert_mode = FALSE; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case '@': insert_chars(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0]); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'b': repeat_char(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] - 1); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'H': case 'f':
                goto_xy(self, 1, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] - 1);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case 'n': report_cursor_pos(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'j':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursorx = ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursory = 0;
		clear_eos(self);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case 'r': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register1:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[1] = 10 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[1] + text[i] - '0';
		break;
	    case ';': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[2] = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Register2; break;
	    case 'm': set_attrib(self, 2); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'H': case 'f':
                goto_xy(self, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[1] - 1, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[0] - 1);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
		break;
	    case 'r': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register2:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[2] = 10 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[2] + text[i] - '0';
		break;
	    case ';': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[3] = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Register3; break;
	    case 'm': set_attrib(self, 3); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    default: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register3:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[3] = 10 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[3] + text[i] - '0';
		break;
	    case ';': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[4] = 0; ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Register4; break;
	    case 'm': set_attrib(self, 4); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    default: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register4:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[4] = 10 * ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.escparm[4] + text[i] - '0';
		break;
	    case 'm': set_attrib(self, 5); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    default: ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case EscLBGT:				/* Seen \E[> */
	    switch (text[i]) {
	    case '2': ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = EscLBGT2; break;
	    default:
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, '>');
		add_char(self, text[i]);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
	    }
	    break;
	case EscLBGT2:				/* Seen \E[>2 */
	    switch (text[i]) {
	    case 'h': memory_lock(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    case 'l': memory_unlock(self); ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init; break;
	    default:
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, '>');
		add_char(self, '2');
		add_char(self, text[i]);
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.state = Init;
	    }
		break;
	default:
	    assert(! "Cannot happen");
	}
    }

    /* Finally redraw all lines that are marked as `dirty' */
    if (XtIsRealized(self)) {
	framewd = compute_framewd(self);
	for (i = 0; i < ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.rows; i++)
	    if (((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][0] & ATTRIB_DIRTY) {
		((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.attribs[i][0] &= ~ATTRIB_DIRTY;
		draw_line(self, framewd, i, 0, ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.columns);
	    }
	do toggle_cursor(self); while (! ((XfwfAnsiTermWidget)self)->xfwfAnsiTerm.cursor_on);
    }
}
#line 125 "AnsiTerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 125 "AnsiTerm.w"
void  XfwfAnsiWrite(Widget self,char * buf,int  nbytes)
#else
#line 125 "AnsiTerm.w"
void  XfwfAnsiWrite(self,buf,nbytes)Widget self;char * buf;int  nbytes;
#endif
#line 126 "AnsiTerm.w"
{
    if (! XtIsSubclass(self, xfwfAnsiTermWidgetClass))
	XtAppError(XtWidgetToApplicationContext(self),
		   "XfwfAnsiWrite may only be called for AnsiTerm widgets.");
    ((XfwfAnsiTermWidgetClass)self->core.widget_class)->xfwfAnsiTerm_class.write(self, buf, nbytes);
}
#line 136 "AnsiTerm.w"
#line 143 "AnsiTerm.w"

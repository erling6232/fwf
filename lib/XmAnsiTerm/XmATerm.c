/* Generated by wbuild from "XmATerm.w"
** (generator version $Revision$ of $Date$)
*/
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#line 1551 "XmATerm.w"
#include <assert.h>
#line 1552 "XmATerm.w"
#include <stdio.h>
#line 1553 "XmATerm.w"
#include <X11/Xatom.h>
#line 1554 "XmATerm.w"
#include <X11/Xfuncs.h>
#line 1555 "XmATerm.w"
#include <X11/keysym.h>
#line 1556 "XmATerm.w"
#include <X11/Xmu/Xmu.h>
#include <Xfwf/XmATermP.h>
#line 691 "XmATerm.w"
static void key(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 738 "XmATerm.w"
static void start_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 755 "XmATerm.w"
static void extend_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 816 "XmATerm.w"
static void end_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 877 "XmATerm.w"
static void paste_selection(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);
#line 885 "XmATerm.w"
static void traverseCurrent(
#if NeedFunctionPrototypes
Widget,XEvent*,String*,Cardinal*
#endif
);

static XtActionsRec actionsList[] = {
{"key", key},
{"start_selection", start_selection},
{"extend_selection", extend_selection},
{"end_selection", end_selection},
{"paste_selection", paste_selection},
{"traverseCurrent", traverseCurrent},
};

static char defaultTranslations[] = "\
Shift<Btn1Down>: extend_selection() \n\
<Btn1Down>: start_selection() traverseCurrent() \n\
<Btn1Motion>: extend_selection() \n\
<Btn1Up>: end_selection() \n\
<Btn2Down>: paste_selection() \n\
<Map>: traverseCurrent() \n\
";
static void _resolve_inheritance(
#if NeedFunctionPrototypes
WidgetClass
#endif
);
#line 265 "XmATerm.w"
static void initialize(
#if NeedFunctionPrototypes
Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 309 "XmATerm.w"
static Boolean  set_values(
#if NeedFunctionPrototypes
Widget ,Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 362 "XmATerm.w"
static XtGeometryResult  query_geometry(
#if NeedFunctionPrototypes
Widget,XtWidgetGeometry *,XtWidgetGeometry *
#endif
);
#line 386 "XmATerm.w"
static void resize(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 410 "XmATerm.w"
static void destroy(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 439 "XmATerm.w"
static void expose(
#if NeedFunctionPrototypes
Widget,XEvent *,Region 
#endif
);
#line 484 "XmATerm.w"
static void write(
#if NeedFunctionPrototypes
Widget,char *,int 
#endif
);
#line 899 "XmATerm.w"
#define max(a, b) ((a )>(b )?(a ):(b ))


#line 900 "XmATerm.w"
#define min(a, b) ((a )<(b )?(a ):(b ))


#line 906 "XmATerm.w"
static void draw_line(
#if NeedFunctionPrototypes
Widget,int ,int ,int ,int 
#endif
);
#line 944 "XmATerm.w"
static Boolean  convert_proc(
#if NeedFunctionPrototypes
Widget,Atom *,Atom *,Atom *,XtPointer *,unsigned  long *,int *
#endif
);
#line 989 "XmATerm.w"
static void lose_ownership_proc(
#if NeedFunctionPrototypes
Widget,Atom *
#endif
);
#line 996 "XmATerm.w"
static void paste_callback(
#if NeedFunctionPrototypes
Widget,XtPointer ,Atom *,Atom *,XtPointer ,unsigned  long *,int *
#endif
);
#line 1016 "XmATerm.w"
static void compute_cell_size(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1039 "XmATerm.w"
static int  compute_framewd(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1050 "XmATerm.w"
#define myrealloc(p, n) ((XtPointer )XtRealloc ((XtPointer )(p ),(n )*sizeof (*(p ))))


#line 1052 "XmATerm.w"
static void allocate_contents(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1095 "XmATerm.w"
static void toggle_cursor(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1113 "XmATerm.w"
static void blink_handler(
#if NeedFunctionPrototypes
XtPointer ,XtIntervalId *
#endif
);
#line 1131 "XmATerm.w"
static void map_handler(
#if NeedFunctionPrototypes
Widget,XtPointer ,XEvent *,Boolean *
#endif
);
#line 1143 "XmATerm.w"
static void make_gc(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1194 "XmATerm.w"
static void add_char(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1220 "XmATerm.w"
static void repeat_char(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1230 "XmATerm.w"
static void next_tabstop(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1248 "XmATerm.w"
static void delete_line(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1270 "XmATerm.w"
static void cursor_down(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1287 "XmATerm.w"
static void clear_eol(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1297 "XmATerm.w"
static void clear_eos(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1316 "XmATerm.w"
static void delete_char(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1330 "XmATerm.w"
static void insert_chars(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1347 "XmATerm.w"
static void insert_line(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1370 "XmATerm.w"
static void set_attrib(
#if NeedFunctionPrototypes
Widget,int 
#endif
);
#line 1391 "XmATerm.w"
static void memory_lock(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1396 "XmATerm.w"
static void memory_unlock(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1404 "XmATerm.w"
static void goto_xy(
#if NeedFunctionPrototypes
Widget,int ,int 
#endif
);
#line 1415 "XmATerm.w"
static void report_cursor_pos(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1427 "XmATerm.w"
static void find_cell(
#if NeedFunctionPrototypes
Widget,int ,int ,int ,int *,int *
#endif
);
#line 1448 "XmATerm.w"
#define F_FOUNDRY 1 


#line 1449 "XmATerm.w"
#define F_FAMILY 2 


#line 1450 "XmATerm.w"
#define F_WEIGHT 3 


#line 1451 "XmATerm.w"
#define F_SLANT 4 


#line 1452 "XmATerm.w"
#define F_SET_WIDTH 5 


#line 1453 "XmATerm.w"
#define F_SANS 6 


#line 1454 "XmATerm.w"
#define F_PIXELS 7 


#line 1455 "XmATerm.w"
#define F_POINTS 8 


#line 1456 "XmATerm.w"
#define F_HRESOLUTION 9 


#line 1457 "XmATerm.w"
#define F_VRESOLUTION 10 


#line 1458 "XmATerm.w"
#define F_SPACING 11 


#line 1459 "XmATerm.w"
#define F_AVG_WITH 12 


#line 1460 "XmATerm.w"
#define F_CHARSET 13 


#line 1462 "XmATerm.w"
static Boolean  parse_font_name(
#if NeedFunctionPrototypes
String ,String *
#endif
);
#line 1484 "XmATerm.w"
static void infer_bold(
#if NeedFunctionPrototypes
Widget,int ,XrmValue *
#endif
);
#line 1517 "XmATerm.w"
static void handle_keys(
#if NeedFunctionPrototypes
Widget,XtPointer ,XEvent *,Boolean *
#endif
);
#line 906 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 906 "XmATerm.w"
static void draw_line(Widget self,int  framewd,int  row,int  lft,int  rgt)
#else
#line 906 "XmATerm.w"
static void draw_line(self,framewd,row,lft,rgt)Widget self;int  framewd;int  row;int  lft;int  rgt;
#endif
#line 907 "XmATerm.w"
{
    Display *dpy = XtDisplay(self);
    Window win = XtWindow(self);
    int x, y, i, n;
    GC use_gc;

    x = framewd + ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + lft * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;
    y = framewd + ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + row * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight + ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->ascent;
    while (lft < rgt) {
	i = lft + 1;
	while (i < rgt && ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[row][i] == ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[row][lft]) i++;
        if (((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[row][lft] & ATTRIB_INVIS) {
            XClearArea(dpy, win, x, y - ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->ascent, n * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth,
		       ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight, FALSE);
        } else {
	    switch (((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[row][lft] & (ATTRIB_REV | ATTRIB_BOLD)) {
	    case 0: use_gc = ((XmAnsiTermWidget)self)->xmAnsiTerm.gc; break;
	    case ATTRIB_BOLD: use_gc = ((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc; break;
	    case ATTRIB_REV: use_gc = ((XmAnsiTermWidget)self)->xmAnsiTerm.revgc; break;
	    case ATTRIB_REV | ATTRIB_BOLD: use_gc = ((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc; break;
	    }
	    n = i - lft;
	    XDrawImageString(dpy, win, use_gc, x, y, &((XmAnsiTermWidget)self)->xmAnsiTerm.contents[row][lft], n);
	    if (((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[row][lft] & ATTRIB_ULINE)
		XDrawLine(dpy, win, use_gc, x, y + ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_pos,
			  x + n * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth - 1, y + ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_pos);
	}
	lft = i;
	x += n * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;
    }
}
#line 944 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 944 "XmATerm.w"
static Boolean  convert_proc(Widget self,Atom * selection,Atom * target,Atom * type_return,XtPointer * value_return,unsigned  long * length_return,int * format_return)
#else
#line 944 "XmATerm.w"
static Boolean  convert_proc(self,selection,target,type_return,value_return,length_return,format_return)Widget self;Atom * selection;Atom * target;Atom * type_return;XtPointer * value_return;unsigned  long * length_return;int * format_return;
#endif
#line 945 "XmATerm.w"
{
    if (*target == XA_TARGETS(XtDisplay(self))) {

	XSelectionRequestEvent *req;
	Atom *targetP;
	Atom *std_targets;
	unsigned long std_length;

	req = XtGetSelectionRequest(self, *selection, NULL);
	XmuConvertStandardSelection(self, req->time, selection, target,
	    type_return, (XtPointer *) &std_targets, &std_length,
	    format_return);
	*value_return = XtMalloc(sizeof(Atom) * (std_length + 1));
	targetP = *(Atom **) value_return;
	*length_return = std_length + 1;
	*targetP++ = XA_STRING;
	bcopy((char*)std_targets, (char*)targetP, sizeof(Atom) * std_length);
	XtFree((char *) std_targets);
	*type_return = XA_ATOM;
	*format_return = sizeof(Atom) * 8;
	return TRUE;

    } else if (*target == XA_STRING) {
	*value_return = ((XmAnsiTermWidget)self)->xmAnsiTerm.selection;
	*type_return = XA_STRING;
	*length_return = ((XmAnsiTermWidget)self)->xmAnsiTerm.selection_len;
	*format_return = 8;
	return TRUE;
	
    } else {

	if (XmuConvertStandardSelection(self, CurrentTime, selection, target,
		type_return, value_return, length_return, format_return))
	    return TRUE;
	else
	    return FALSE;
    }
}
#line 989 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 989 "XmATerm.w"
static void lose_ownership_proc(Widget self,Atom * selection)
#else
#line 989 "XmATerm.w"
static void lose_ownership_proc(self,selection)Widget self;Atom * selection;
#endif
#line 990 "XmATerm.w"
{}
#line 996 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 996 "XmATerm.w"
static void paste_callback(Widget self,XtPointer  client_data,Atom * selection,Atom * type,XtPointer  value,unsigned  long * length,int * format)
#else
#line 996 "XmATerm.w"
static void paste_callback(self,client_data,selection,type,value,length,format)Widget self;XtPointer  client_data;Atom * selection;Atom * type;XtPointer  value;unsigned  long * length;int * format;
#endif
#line 997 "XmATerm.w"
{
    char *text = (char *) value;
    int i;

    assert(*selection == XA_PRIMARY && *type == XA_STRING && *format == 8);

    if (value == NULL && *length == 0) {
	XBell(XtDisplay(self), 0);
	return;
    }
    for (i = 0; i < *length; i++)
	XtCallCallbackList(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.keyCallback, (XtPointer) &text[i]);
    XtFree(value);
}
#line 1016 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1016 "XmATerm.w"
static void compute_cell_size(Widget self)
#else
#line 1016 "XmATerm.w"
static void compute_cell_size(self)Widget self;
#endif
#line 1017 "XmATerm.w"
{
    unsigned long h1, h2;

    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.fnt, XA_QUAD_WIDTH, &h1))
	h1 = XTextWidth(((XmAnsiTermWidget)self)->xmAnsiTerm.fnt, "M", 1);
    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont, XA_QUAD_WIDTH, &h2))
	h2 = XTextWidth(((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont, "M", 1);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth = max(h1, h2);

    h1 = ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->ascent + ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->descent;
    h2 = ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont->ascent + ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont->descent;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight = max(h1, h2);

    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.fnt, XA_UNDERLINE_POSITION, &h1)) h1 = 2;
    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont, XA_UNDERLINE_POSITION, &h2)) h2 = 2;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_pos = max(h1, h2);

    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.fnt, XA_UNDERLINE_THICKNESS, &h1)) h1 = 1;
    if (! XGetFontProperty(((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont, XA_UNDERLINE_THICKNESS, &h2)) h2 = 1;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_thick = max(h1, h2);
}
#line 1039 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1039 "XmATerm.w"
static int  compute_framewd(Widget self)
#else
#line 1039 "XmATerm.w"
static int  compute_framewd(self)Widget self;
#endif
#line 1040 "XmATerm.w"
{
    return ((XmAnsiTermWidget)self)->xmPrimitive.shadow_thickness;
}
#line 1052 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1052 "XmATerm.w"
static void allocate_contents(Widget self)
#else
#line 1052 "XmATerm.w"
static void allocate_contents(self)Widget self;
#endif
#line 1053 "XmATerm.w"
{
    int i, j;

    /* Remove superfluous lines */
    for (i = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows; i++) {
	XtFree(((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i]);
	XtFree(((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i]);
    }
    /* Allocate and initialize new lines */
    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents = myrealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.contents, ((XmAnsiTermWidget)self)->xmAnsiTerm.rows);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs = myrealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.attribs, ((XmAnsiTermWidget)self)->xmAnsiTerm.rows);
    for (i = ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows; i++) {
	((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i] = XtMalloc(((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i] = XtMalloc(((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
	for (j = 0; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) {
	    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i][j] = ' ';
	    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] = 0;
	}
    }
    /* Lengthen or shorten existing lines */
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_columns != ((XmAnsiTermWidget)self)->xmAnsiTerm.columns) {
	for (i = 0; i < min(((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows, ((XmAnsiTermWidget)self)->xmAnsiTerm.rows); i++) {
	    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i] = myrealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i], ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
	    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i] = myrealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i], ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
	    for (j = ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_columns; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) {
		((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i][j] = ' ';
		((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] = 0;
	    }
	}
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_columns = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns;
}
#line 1095 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1095 "XmATerm.w"
static void toggle_cursor(Widget self)
#else
#line 1095 "XmATerm.w"
static void toggle_cursor(self)Widget self;
#endif
#line 1096 "XmATerm.w"
{
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursor_on) {				/* Restore to normal */
	draw_line(self, compute_framewd(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.old_cy, ((XmAnsiTermWidget)self)->xmAnsiTerm.old_cx, ((XmAnsiTermWidget)self)->xmAnsiTerm.old_cx + 1);
    } else if (((XmAnsiTermWidget)self)->xmPrimitive.highlighted) {			/* Draw in reverse */
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] ^= ATTRIB_REV;
	draw_line(self, compute_framewd(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory, ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx, ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx + 1);
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] ^= ATTRIB_REV;
    } else {					/* Draw with underline */
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] ^= ATTRIB_ULINE;
	draw_line(self, compute_framewd(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory, ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx, ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx + 1);
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] ^= ATTRIB_ULINE;
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.old_cx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.old_cy = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursor_on = ! ((XmAnsiTermWidget)self)->xmAnsiTerm.cursor_on;
}
#line 1113 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1113 "XmATerm.w"
static void blink_handler(XtPointer  client_data,XtIntervalId * id)
#else
#line 1113 "XmATerm.w"
static void blink_handler(client_data,id)XtPointer  client_data;XtIntervalId * id;
#endif
#line 1114 "XmATerm.w"
{
    Widget self = (Widget) client_data;
    toggle_cursor(self);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
			     500, blink_handler, self);
}
#line 1131 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1131 "XmATerm.w"
static void map_handler(Widget self,XtPointer  client_data,XEvent * event,Boolean * cont)
#else
#line 1131 "XmATerm.w"
static void map_handler(self,client_data,event,cont)Widget self;XtPointer  client_data;XEvent * event;Boolean * cont;
#endif
#line 1132 "XmATerm.w"
{
    if (event->type == MapNotify)
	((XmAnsiTermWidget)self)->xmAnsiTerm.timer = XtAppAddTimeOut(XtWidgetToApplicationContext(self),
				 500, blink_handler, self);
    else if (event->type == UnmapNotify)
	XtRemoveTimeOut(((XmAnsiTermWidget)self)->xmAnsiTerm.timer);
}
#line 1143 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1143 "XmATerm.w"
static void make_gc(Widget self)
#else
#line 1143 "XmATerm.w"
static void make_gc(self)Widget self;
#endif
#line 1144 "XmATerm.w"
{
    XGCValues values;
    XtGCMask mask, dynmask, dontmask;

    mask = GCFont | GCForeground | GCBackground | GCLineWidth;
    dynmask = GCClipMask;
    dontmask = GCArcMode | GCDashOffset | GCDashList | GCFillRule |
	GCFillStyle | GCJoinStyle | GCStipple | GCFillRule | GCTile |
	GCTileStipXOrigin | GCTileStipYOrigin;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.gc) XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.gc);
    values.font = ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->fid;
    values.foreground = ((XmAnsiTermWidget)self)->xmPrimitive.foreground;
    values.background = ((XmAnsiTermWidget)self)->core.background_pixel;
    values.line_width = ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_thick;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.gc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc) XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc);
    values.font = ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont->fid;
    values.foreground = ((XmAnsiTermWidget)self)->xmPrimitive.foreground;
    values.background = ((XmAnsiTermWidget)self)->core.background_pixel;
    values.line_width = ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_thick;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.revgc) XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.revgc);
    values.font = ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt->fid;
    values.foreground = ((XmAnsiTermWidget)self)->core.background_pixel;
    values.background = ((XmAnsiTermWidget)self)->xmPrimitive.foreground;
    values.line_width = ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_thick;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.revgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc) XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc);
    values.font = ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont->fid;
    values.foreground = ((XmAnsiTermWidget)self)->core.background_pixel;
    values.background = ((XmAnsiTermWidget)self)->xmPrimitive.foreground;
    values.line_width = ((XmAnsiTermWidget)self)->xmAnsiTerm.uline_thick;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc = XtAllocateGC(self, 0, mask, &values, dynmask, dontmask);
}
#line 1194 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1194 "XmATerm.w"
static void add_char(Widget self,int  c)
#else
#line 1194 "XmATerm.w"
static void add_char(self,c)Widget self;int  c;
#endif
#line 1195 "XmATerm.w"
{
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.insert_mode) {
        bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx],
              &((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+1], ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - 1);
        bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx],
              &((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+1], ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - 1);
        ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] = c;
        ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] = ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib;
    } else {
        ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] = c;
        ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx] = ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib;
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1)
        ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx++;
    else {					/* Margin reached */
        ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = 0;				/* CR */
        cursor_down(self);				/* LF */
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.last_char = c;				/* Save for repeat_char() */
}
#line 1220 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1220 "XmATerm.w"
static void repeat_char(Widget self,int  n)
#else
#line 1220 "XmATerm.w"
static void repeat_char(self,n)Widget self;int  n;
#endif
#line 1221 "XmATerm.w"
{
    for (; n > 0; n--) add_char(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.last_char);
}
#line 1230 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1230 "XmATerm.w"
static void next_tabstop(Widget self)
#else
#line 1230 "XmATerm.w"
static void next_tabstop(self)Widget self;
#endif
#line 1231 "XmATerm.w"
{
    if (! ((XmAnsiTermWidget)self)->xmAnsiTerm.insert_mode) {
	((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx + 8)/8) * 8;
    } else {
	int x = ((((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx + 8)/8) * 8;
	if (x >= ((XmAnsiTermWidget)self)->xmAnsiTerm.columns) x = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1;
	while (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx != x) add_char(self, ' ');
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
    }
}
#line 1248 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1248 "XmATerm.w"
static void delete_line(Widget self)
#else
#line 1248 "XmATerm.w"
static void delete_line(self)Widget self;
#endif
#line 1249 "XmATerm.w"
{
    int i;
    char *swap_contents, *swap_attribs;

    swap_contents = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory];
    swap_attribs = ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory];
    for (i = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1; i++) {
	((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i+1];
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i] = ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i+1];
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][0] |= ATTRIB_DIRTY;
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1] = swap_contents;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1] = swap_attribs;
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1][0], ' ', ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1][0], 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1][0] |= ATTRIB_DIRTY;
}
#line 1270 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1270 "XmATerm.w"
static void cursor_down(Widget self)
#else
#line 1270 "XmATerm.w"
static void cursor_down(self)Widget self;
#endif
#line 1271 "XmATerm.w"
{
    int save_y;
    
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursory < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1)
	((XmAnsiTermWidget)self)->xmAnsiTerm.cursory++;
    else {
	save_y = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;
        ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = ((XmAnsiTermWidget)self)->xmAnsiTerm.locked_lines;
	delete_line(self);
	((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = save_y;
    }
}
#line 1287 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1287 "XmATerm.w"
static void clear_eol(Widget self)
#else
#line 1287 "XmATerm.w"
static void clear_eol(self)Widget self;
#endif
#line 1288 "XmATerm.w"
{
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], ' ', ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx);
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1297 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1297 "XmATerm.w"
static void clear_eos(Widget self)
#else
#line 1297 "XmATerm.w"
static void clear_eos(self)Widget self;
#endif
#line 1298 "XmATerm.w"
{
    int i, save_x, save_y;

    clear_eol(self);
    save_x = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx;
    save_y = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = 0;
    for (i = save_y + 1; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows; i++) {
	((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = i;
	clear_eol(self);
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = save_x;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = save_y;
}
#line 1316 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1316 "XmATerm.w"
static void delete_char(Widget self)
#else
#line 1316 "XmATerm.w"
static void delete_char(self)Widget self;
#endif
#line 1317 "XmATerm.w"
{
    bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+1], &((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx],
          ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - 1);
    bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+1], &((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx],
          ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - 1);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.columns-1] = ' ';
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.columns-1] = 0;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1330 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1330 "XmATerm.w"
static void insert_chars(Widget self,int  n)
#else
#line 1330 "XmATerm.w"
static void insert_chars(self,n)Widget self;int  n;
#endif
#line 1331 "XmATerm.w"
{
    if (n > ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx) n = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx;
    bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], &((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+n],
          ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - n);
    bcopy(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], &((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx+n],
          ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx - n);
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], ' ', n);
    memset(&((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx], 0, n);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1347 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1347 "XmATerm.w"
static void insert_line(Widget self)
#else
#line 1347 "XmATerm.w"
static void insert_line(self)Widget self;
#endif
#line 1348 "XmATerm.w"
{
    int i;
    char *swap_contents, *swap_attribs;

    swap_contents = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1];
    swap_attribs = ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.rows-1];
    for (i = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1; i > ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory; i--) {
	((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i-1];
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i] = ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i-1];
	((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][0] |= ATTRIB_DIRTY;
    }
    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory] = swap_contents;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory] = swap_attribs;
    memset(((XmAnsiTermWidget)self)->xmAnsiTerm.contents[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory], ' ', ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
    memset(((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory], 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[((XmAnsiTermWidget)self)->xmAnsiTerm.cursory][0] |= ATTRIB_DIRTY;
}
#line 1370 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1370 "XmATerm.w"
static void set_attrib(Widget self,int  n)
#else
#line 1370 "XmATerm.w"
static void set_attrib(self,n)Widget self;int  n;
#endif
#line 1371 "XmATerm.w"
{
    int i;

    for (i = 0; i < n; i++) {
	switch(((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[i]) {
	case 0: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib = 0; break;
	case 1: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib |= ATTRIB_BOLD; break;
	case 4: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib |= ATTRIB_ULINE; break;
	case 5: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib |= ATTRIB_BOLD; break; /* Should be: blinking */
	case 7: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib |= ATTRIB_REV; break;
        case 8: ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib |= ATTRIB_INVIS; break;
	}
    }
}
#line 1391 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1391 "XmATerm.w"
static void memory_lock(Widget self)
#else
#line 1391 "XmATerm.w"
static void memory_lock(self)Widget self;
#endif
#line 1392 "XmATerm.w"
{
    ((XmAnsiTermWidget)self)->xmAnsiTerm.locked_lines = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;                  /* Lock lines above cursor */
}
#line 1396 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1396 "XmATerm.w"
static void memory_unlock(Widget self)
#else
#line 1396 "XmATerm.w"
static void memory_unlock(self)Widget self;
#endif
#line 1397 "XmATerm.w"
{
    ((XmAnsiTermWidget)self)->xmAnsiTerm.locked_lines = 0;
}
#line 1404 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1404 "XmATerm.w"
static void goto_xy(Widget self,int  x,int  y)
#else
#line 1404 "XmATerm.w"
static void goto_xy(self,x,y)Widget self;int  x;int  y;
#endif
#line 1405 "XmATerm.w"
{
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = max(0, min(((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1, x));
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = max(0, min(((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1, y));
}
#line 1415 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1415 "XmATerm.w"
static void report_cursor_pos(Widget self)
#else
#line 1415 "XmATerm.w"
static void report_cursor_pos(self)Widget self;
#endif
#line 1416 "XmATerm.w"
{
    char s[25];
    int i, n;

    n = sprintf(s, "\033[%d;%dR", ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory + 1, ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx + 1);
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.keyCallback, &s[i]);
}
#line 1427 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1427 "XmATerm.w"
static void find_cell(Widget self,int  framewd,int  cx,int  cy,int * col,int * row)
#else
#line 1427 "XmATerm.w"
static void find_cell(self,framewd,cx,cy,col,row)Widget self;int  framewd;int  cx;int  cy;int * col;int * row;
#endif
#line 1428 "XmATerm.w"
{
    int i, j, x, y;

    for (x = framewd + ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth, i = 0;
	i < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1 && x < cx;
	i++, x += ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth) ;

    for (y = framewd + ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight, j = 0;
	j < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1 && y < cy;
	j++, y += ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight) ;

    *col = i;
    *row = j;
}
#line 1462 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1462 "XmATerm.w"
static Boolean  parse_font_name(String  name,String * table)
#else
#line 1462 "XmATerm.w"
static Boolean  parse_font_name(name,table)String  name;String * table;
#endif
#line 1463 "XmATerm.w"
{
    int i, field;

    if (name == NULL || name[0] != '-') return False;
    table[0] = XtNewString(name);
    for (i = field = 0; name[i] != '\0'; i++) {
	if (name[i] == '-') {
	    field++;
	    table[0][i] = '\0';
	    table[field] = &table[0][i+1];
	    if (field == 13) break;		/* No more fields */
	}
    }
    return True;
}
#line 1484 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1484 "XmATerm.w"
static void infer_bold(Widget self,int  offset,XrmValue * value)
#else
#line 1484 "XmATerm.w"
static void infer_bold(self,offset,value)Widget self;int  offset;XrmValue * value;
#endif
#line 1485 "XmATerm.w"
{
    static XFontStruct *fs = NULL;
    String info[15];
    char s[250];

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.font == NULL)
	XtAppError(XtWidgetToApplicationContext(self),
		   "Font resource may not be NULL in AnsiTerm widget");

    if (parse_font_name(((XmAnsiTermWidget)self)->xmAnsiTerm.font, info)) {
	sprintf(s, "-%s-%s-%s-%s-*-%s-*-%s-%s-%s-%s-*-%s",
		info[F_FOUNDRY], info[F_FAMILY], "bold",
		info[F_SLANT], /* info[F_SET_WIDTH], */ info[F_SANS],
		/* info[F_PIXELS], */ info[F_POINTS], info[F_HRESOLUTION],
		info[F_VRESOLUTION], info[F_SPACING],
		/* info[F_AVG_WIDTH], */ info[F_CHARSET]);
	fs = XLoadQueryFont(XtDisplay(self), s);
    }
    if (! fs)					/* Try font unchanged */
	fs = XLoadQueryFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.font);
    if (! fs)
	XtAppWarning(XtWidgetToApplicationContext(self),
		   "Couldn't find font for AnsiTerm widget");
    value->addr = (XtPointer) &fs;
}
#line 1517 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1517 "XmATerm.w"
static void handle_keys(Widget self,XtPointer  client_data,XEvent * event,Boolean * cont)
#else
#line 1517 "XmATerm.w"
static void handle_keys(self,client_data,event,cont)Widget self;XtPointer  client_data;XEvent * event;Boolean * cont;
#endif
#line 1518 "XmATerm.w"
{
    char buf[15];
    KeySym keysym;
    int n, i;
    
    assert(event->type == KeyPress);

    n = XLookupString(&event->xkey, buf, sizeof(buf), &keysym, NULL);
    if (n == 0)
	switch (keysym) {
	case XK_BackSpace:  n = 1; buf[0] = '\010';	    break;
	case XK_Home:	    n = 3; strcpy(buf, "\033[H");   break;
	case XK_Down:	    n = 3; strcpy(buf, "\033[B");   break;
	case XK_Left:	    n = 3; strcpy(buf, "\033[D");   break;
	case XK_Right:	    n = 3; strcpy(buf, "\033[C");   break;
	case XK_Up:	    n = 3; strcpy(buf, "\033[A");   break;
	case XK_Return:
	case XK_KP_Enter:
	case XK_Linefeed:   n = 1; buf[0] = '\015';	    break;
	case XK_Tab:	    n = 1; buf[0] = '\011';	    break;
	case XK_Delete:     n = 1; buf[0] = '\177';	    break;
	default:
	    if ((event->xkey.state & ControlMask)
		&& 65 <= keysym && keysym <= 95)
		buf[n++] = keysym - 64;	/* Control + letter */
	}
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.keyCallback, &buf[i]);
    if (n != 0) *cont = FALSE;
}

static XtResource resources[] = {
#line 37 "XmATerm.w"
{XtNrows,XtCRows,XtRInt,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.rows),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.rows),XtRImmediate,(XtPointer)24 },
#line 44 "XmATerm.w"
{XtNcolumns,XtCColumns,XtRInt,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.columns),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.columns),XtRImmediate,(XtPointer)80 },
#line 51 "XmATerm.w"
{XtNfont,XtCFont,XtRString,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.font),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.font),XtRImmediate,(XtPointer)XtDefaultFont },
#line 56 "XmATerm.w"
{XtNboldfont,XtCBoldfont,XtRXFontStruct,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.boldfont),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.boldfont),XtRCallProc,(XtPointer)infer_bold },
#line 60 "XmATerm.w"
{XtNmargin,XtCMargin,XtRInt,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.margin),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.margin),XtRImmediate,(XtPointer)10 },
#line 64 "XmATerm.w"
{XtNforeground,XtCForeground,XtRPixel,sizeof(((XmAnsiTermRec*)NULL)->xmPrimitive.foreground),XtOffsetOf(XmAnsiTermRec,xmPrimitive.foreground),XtRString,(XtPointer)XtDefaultForeground },
#line 72 "XmATerm.w"
{XtNkeyCallback,XtCKeyCallback,XtRCallback,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.keyCallback),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.keyCallback),XtRImmediate,(XtPointer)NULL },
#line 80 "XmATerm.w"
{XtNresizeCallback,XtCResizeCallback,XtRCallback,sizeof(((XmAnsiTermRec*)NULL)->xmAnsiTerm.resizeCallback),XtOffsetOf(XmAnsiTermRec,xmAnsiTerm.resizeCallback),XtRImmediate,(XtPointer)NULL },
};

XmAnsiTermClassRec xmAnsiTermClassRec = {
{ /* core_class part */
/* superclass   	*/  (WidgetClass) &xmPrimitiveClassRec,
/* class_name   	*/  "XmAnsiTerm",
/* widget_size  	*/  sizeof(XmAnsiTermRec),
/* class_initialize 	*/  NULL,
/* class_part_initialize*/  _resolve_inheritance,
/* class_inited 	*/  FALSE,
/* initialize   	*/  initialize,
/* initialize_hook 	*/  NULL,
/* realize      	*/  XtInheritRealize,
/* actions      	*/  actionsList,
/* num_actions  	*/  6,
/* resources    	*/  resources,
/* num_resources 	*/  8,
/* xrm_class    	*/  NULLQUARK,
/* compres_motion 	*/  True ,
/* compress_exposure 	*/  XtExposeCompressMultiple |XtExposeGraphicsExpose |XtExposeGraphicsExposeMerged ,
/* compress_enterleave 	*/  True ,
/* visible_interest 	*/  False ,
/* destroy      	*/  destroy,
/* resize       	*/  resize,
/* expose       	*/  expose,
/* set_values   	*/  set_values,
/* set_values_hook 	*/  NULL,
/* set_values_almost 	*/  XtInheritSetValuesAlmost,
/* get_values+hook 	*/  NULL,
/* accept_focus 	*/  XtInheritAcceptFocus,
/* version      	*/  XtVersion,
/* callback_private 	*/  NULL,
/* tm_table      	*/  defaultTranslations,
/* query_geometry 	*/  query_geometry,
/* display_acceleator 	*/  XtInheritDisplayAccelerator,
/* extension    	*/  NULL 
},
{ /* XmPrimitive class part */
XmInheritBorderHighlight,	/* border_highlight */
XmInheritBorderUnhighlight,	/* border_unhighlight */
XtInheritTranslations ,	/* translations */
XmInheritArmAndActivate,	/* arm_and_activate */
0 ,	/* syn_resources */
0 ,	/* num_syn_resources */
#define primitive_extension extension
NULL ,	/* primitive_extension */
},
{ /* XmAnsiTerm_class part */
write,
},
};
WidgetClass xmAnsiTermWidgetClass = (WidgetClass) &xmAnsiTermClassRec;
/*ARGSUSED*/
#line 691 "XmATerm.w"
static void key(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    char buf[15];
    KeySym keysym;
    int n, i;
    
    if (event->type != KeyPress && event->type != KeyRelease)
	XtError("key() action in AnsiTerm not associated with key events");

    n = XLookupString(&event->xkey, buf, sizeof(buf), &keysym, NULL);
    if (n == 0)
	switch (keysym) {
	case XK_BackSpace:  n = 1; buf[0] = '\010';	    break;
	case XK_Home:	    n = 3; strcpy(buf, "\033[H");   break;
	case XK_Down:	    n = 3; strcpy(buf, "\033[B");   break;
	case XK_Left:	    n = 3; strcpy(buf, "\033[D");   break;
	case XK_Right:	    n = 3; strcpy(buf, "\033[C");   break;
	case XK_Up:	    n = 3; strcpy(buf, "\033[A");   break;
	case XK_Return:
	case XK_KP_Enter:
	case XK_Linefeed:   n = 1; buf[0] = '\015';	    break;
	case XK_Tab:	    n = 1; buf[0] = '\011';	    break;
	case XK_Delete:     n = 1; buf[0] = '\177';	    break;
	default:
	    if ((event->xkey.state & ControlMask)
		&& 65 <= keysym && keysym <= 95) {
		buf[n++] = keysym - 64;	/* Control + letter */
	    }
	}
    for (i = 0; i < n; i++) XtCallCallbackList(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.keyCallback, &buf[i]);
}

/*ARGSUSED*/
#line 738 "XmATerm.w"
static void start_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    find_cell(self, compute_framewd(self), event->xbutton.x,
	      event->xbutton.y, &((XmAnsiTermWidget)self)->xmAnsiTerm.start_x, &((XmAnsiTermWidget)self)->xmAnsiTerm.start_y);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.end_x = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_y;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.drag_started = FALSE;			/* No selection yet */
}

/*ARGSUSED*/
#line 755 "XmATerm.w"
static void extend_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    int i, j, framewd, sx, sy, ex, ey, x, y;

    ((XmAnsiTermWidget)self)->xmAnsiTerm.drag_started = TRUE;
    framewd = compute_framewd(self);
    find_cell(self, framewd, event->xbutton.x, event->xbutton.y, &x, &y);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.start_y < y
        || (((XmAnsiTermWidget)self)->xmAnsiTerm.start_y == y && ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x < x)) {
        sy = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_y;  ey = y;
        sx = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x;  ex = x;
    } else {                                   /* Swap start and end */
        sy = y;  ey = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_y;
        sx = x;  ex = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x;
    }    

    /* Draw the lines that the mouse passed over since last event */
    for (i = min(y, ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y); i <= max(y, ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y); i++) {

        /* Toggle REV attribute on cells within selected region */
        if (i == sy && i == ey)
            for (j = sx; j <= ex; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == sy)
            for (j = sx; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == ey)
            for (j = 0; j < ex; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (sy < i && i < ey)
            for (j = 0; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;

        draw_line(self, framewd, i, 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);	/* Draw the line */

        /* Toggle REV attribute on cells in region again */
        if (i == sy && i == ey)
            for (j = sx; j <= ex; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == sy)
            for (j = sx; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (i == ey)
            for (j = 0; j < ex; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
        else if (sy < i && i < ey)
            for (j = 0; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][j] ^= ATTRIB_REV;
    }

    ((XmAnsiTermWidget)self)->xmAnsiTerm.end_x = x;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y = y;
}

/*ARGSUSED*/
#line 816 "XmATerm.w"
static void end_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    int sx, sy, ex, ey, k, i, j, framewd;

    if (! ((XmAnsiTermWidget)self)->xmAnsiTerm.drag_started) return;		/* No movement since BtnDown */

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.start_y < ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y
        || (((XmAnsiTermWidget)self)->xmAnsiTerm.start_y == ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y && ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x < ((XmAnsiTermWidget)self)->xmAnsiTerm.end_x)) {
        sy = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_y;  ey = ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y;
        sx = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x;  ex = ((XmAnsiTermWidget)self)->xmAnsiTerm.end_x;
    } else {					/* Swap start & end */
        sy = ((XmAnsiTermWidget)self)->xmAnsiTerm.end_y;  ey = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_y;
        sx = ((XmAnsiTermWidget)self)->xmAnsiTerm.end_x;  ex = ((XmAnsiTermWidget)self)->xmAnsiTerm.start_x;
    }

    /* Unhighlight the selection */
    framewd = compute_framewd(self);
    if (sy == ey) {
        draw_line(self, framewd, sy, sx, ex + 1);
    } else {
        draw_line(self, framewd, sy, sx, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns); /* First (partial) line */
        for (i = sy + 1; i <= ey - 1; i++)      /* Middle lines */
            draw_line(self, framewd, i, 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
        draw_line(self, framewd, ey, 0, ex + 1);   /* Last (partial) line */
    }

    /* Copy selection to buffer */
    if (sy == ey) {

        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection = XtRealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.selection, ex - sx + 2);
        for (k = 0, j = sx; j <= ex; k++, j++)
            ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[sy][j];
        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = '\0';
        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection_len = k;

    } else {

        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection = XtRealloc(((XmAnsiTermWidget)self)->xmAnsiTerm.selection,
            ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - sx + 1 + (ey - sy - 1) * (((XmAnsiTermWidget)self)->xmAnsiTerm.columns + 1) + ex + 3);
        k = 0;
        for (j = sx; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++, k++)
            ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[sy][j];
        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k++] = '\n';
        for (i = sy + 1; i <= ey - 1; i++) {
            for (j = 0; j < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns; j++, k++)
                ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i][j];
            ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k++] = '\n';
        }
        for (j = 0; j <= ex; j++, k++)
            ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = ((XmAnsiTermWidget)self)->xmAnsiTerm.contents[ey][j];
        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection[k] = '\0';
        ((XmAnsiTermWidget)self)->xmAnsiTerm.selection_len = k;
    }

    /* Now ask the X server for ownership of the selection */
    if (XtOwnSelection(self, XA_PRIMARY, event->xbutton.time,
		       convert_proc, lose_ownership_proc, NULL) == FALSE)
        XtAppWarning(XtWidgetToApplicationContext(self),
		     "Failed to become selection owner");
}

/*ARGSUSED*/
#line 877 "XmATerm.w"
static void paste_selection(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    XtGetSelectionValue(self, XA_PRIMARY, XA_STRING, paste_callback, NULL,
	event->xbutton.time);
}

/*ARGSUSED*/
#line 885 "XmATerm.w"
static void traverseCurrent(self,event,params,num_params)Widget self;XEvent*event;String*params;Cardinal*num_params;
{
    (void) XmProcessTraversal(self, XmTRAVERSE_CURRENT);
/*
    if (! XmProcessTraversal($, XmTRAVERSE_CURRENT))
	fprintf(stderr, "%s: set_focus() failed\n", XtName($));
    else
	fprintf(stderr, "%s: set_focus() succeeded\n", XtName($));
	*/
}

static void _resolve_inheritance(class)
WidgetClass class;
{
  XmAnsiTermWidgetClass c = (XmAnsiTermWidgetClass) class;
  XmAnsiTermWidgetClass super;
  if (class == xmAnsiTermWidgetClass) return;
  super = (XmAnsiTermWidgetClass)class->core_class.superclass;
  if (c->xmAnsiTerm_class.write == XtInherit_write)
    c->xmAnsiTerm_class.write = super->xmAnsiTerm_class.write;
}
#line 265 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 265 "XmATerm.w"
static void initialize(Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 265 "XmATerm.w"
static void initialize(request,self,args,num_args)Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 266 "XmATerm.w"
{
    int framewd = 2 * compute_framewd(self);

    (void) XmuInternAtom(XtDisplay(self), XmuMakeAtom("NULL"));
    ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt = XLoadQueryFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.font);
    if (! ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt)
	XtAppError(XtWidgetToApplicationContext(self),
		   "Failed to find font in AnsiTerm");
    compute_cell_size(self);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.columns < 1) ((XmAnsiTermWidget)self)->xmAnsiTerm.columns = 1;
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.rows < 1) ((XmAnsiTermWidget)self)->xmAnsiTerm.rows = 1;
    ((XmAnsiTermWidget)self)->core.width = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.columns * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;
    ((XmAnsiTermWidget)self)->core.height = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.rows * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight;

    ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_columns = ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows = 0;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.contents = ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs = NULL;
    allocate_contents(self);

    XtAddEventHandler(self, StructureNotifyMask, FALSE, map_handler, NULL);
    XtInsertEventHandler(self, KeyPressMask, FALSE, handle_keys, NULL,
			 XtListHead);

    ((XmAnsiTermWidget)self)->xmAnsiTerm.gc = ((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc = ((XmAnsiTermWidget)self)->xmAnsiTerm.revgc = ((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc = NULL;
    make_gc(self);

    ((XmAnsiTermWidget)self)->xmAnsiTerm.savedx = ((XmAnsiTermWidget)self)->xmAnsiTerm.savedy = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = 0;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cursor_on = FALSE;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib = 0;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.insert_mode = FALSE;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.last_char = ' ';
    ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.selection = NULL;
    ((XmAnsiTermWidget)self)->xmAnsiTerm.locked_lines = 0;
}
#line 309 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 309 "XmATerm.w"
static Boolean  set_values(Widget  old,Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 309 "XmATerm.w"
static Boolean  set_values(old,request,self,args,num_args)Widget  old;Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 310 "XmATerm.w"
{
    Bool redraw = FALSE, need_gc = FALSE;
    int framewd = 2 * compute_framewd(self);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.font != ((XmAnsiTermWidget)old)->xmAnsiTerm.font || ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont != ((XmAnsiTermWidget)old)->xmAnsiTerm.boldfont) {
	if (((XmAnsiTermWidget)self)->xmAnsiTerm.fnt) XFreeFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt);
	((XmAnsiTermWidget)self)->xmAnsiTerm.fnt = XLoadQueryFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.font);
	need_gc = TRUE;
	compute_cell_size(self);
    }
    if (((XmAnsiTermWidget)self)->xmPrimitive.foreground != ((XmAnsiTermWidget)old)->xmPrimitive.foreground
	|| ((XmAnsiTermWidget)self)->core.background_pixel != ((XmAnsiTermWidget)old)->core.background_pixel) {
	need_gc = TRUE;
    }

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.columns < 1) ((XmAnsiTermWidget)self)->xmAnsiTerm.columns = 1;		/* Silently increase */
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.rows < 1) ((XmAnsiTermWidget)self)->xmAnsiTerm.rows = 1;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.columns != ((XmAnsiTermWidget)old)->xmAnsiTerm.columns)
	((XmAnsiTermWidget)self)->core.width = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.columns * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;
    else if (((XmAnsiTermWidget)self)->core.width != ((XmAnsiTermWidget)old)->core.width)
	((XmAnsiTermWidget)self)->xmAnsiTerm.columns = max(1, (((XmAnsiTermWidget)self)->core.width - framewd - 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin)/((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth);
    else if (((XmAnsiTermWidget)self)->xmAnsiTerm.margin != ((XmAnsiTermWidget)old)->xmAnsiTerm.margin || ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth != ((XmAnsiTermWidget)old)->xmAnsiTerm.cellwidth)
	((XmAnsiTermWidget)self)->core.width = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.columns * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.rows != ((XmAnsiTermWidget)old)->xmAnsiTerm.rows)
	((XmAnsiTermWidget)self)->core.height = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.rows * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight;
    else if (((XmAnsiTermWidget)self)->core.height != ((XmAnsiTermWidget)old)->core.height)
	((XmAnsiTermWidget)self)->xmAnsiTerm.rows = max(1, (((XmAnsiTermWidget)self)->core.height - framewd - 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin)/((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight);
    else if (((XmAnsiTermWidget)self)->xmAnsiTerm.margin != ((XmAnsiTermWidget)old)->xmAnsiTerm.margin || ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight != ((XmAnsiTermWidget)old)->xmAnsiTerm.cellheight)
	((XmAnsiTermWidget)self)->core.height = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.rows * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.rows != ((XmAnsiTermWidget)old)->xmAnsiTerm.rows || ((XmAnsiTermWidget)self)->xmAnsiTerm.columns != ((XmAnsiTermWidget)old)->xmAnsiTerm.columns)
	allocate_contents(self);
	
    if (need_gc) {
	make_gc(self);
	redraw = TRUE;
    }
    if (((XmAnsiTermWidget)self)->core.width != ((XmAnsiTermWidget)old)->core.width || ((XmAnsiTermWidget)self)->core.height != ((XmAnsiTermWidget)old)->core.height)
	redraw = FALSE;			/* Don't redraw if resizing */

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx >= ((XmAnsiTermWidget)self)->xmAnsiTerm.columns) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1;
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursory >= ((XmAnsiTermWidget)self)->xmAnsiTerm.rows) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1;

    return redraw;
}
#line 362 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 362 "XmATerm.w"
static XtGeometryResult  query_geometry(Widget self,XtWidgetGeometry * request,XtWidgetGeometry * reply)
#else
#line 362 "XmATerm.w"
static XtGeometryResult  query_geometry(self,request,reply)Widget self;XtWidgetGeometry * request;XtWidgetGeometry * reply;
#endif
#line 363 "XmATerm.w"
{
    int framewd = compute_framewd(self);

    /* Compute our preferred geometry */
    reply->request_mode = CWWidth | CWHeight;
    reply->width = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.columns * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth;
    reply->height = framewd + 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin + ((XmAnsiTermWidget)self)->xmAnsiTerm.rows * ((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight;

    if ((!(request->request_mode & CWWidth)
	 || request->width == reply->width)
	&& (!(request->request_mode & CWHeight)
	    || request->height == reply->height))
	return XtGeometryYes;			/* Accept the request */

    if (((XmAnsiTermWidget)self)->core.width == reply->width && ((XmAnsiTermWidget)self)->core.height == reply->height)
	return XtGeometryNo;			/* Ask for no change */

    return XtGeometryAlmost;			/* We supply an alternative */
}
#line 386 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 386 "XmATerm.w"
static void resize(Widget self)
#else
#line 386 "XmATerm.w"
static void resize(self)Widget self;
#endif
#line 387 "XmATerm.w"
{
    XfwfResizeInfo cb_info;
    int oldcolumns = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns, oldrows = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows;
    int framewd = 2 * compute_framewd(self);

    ((XmAnsiTermWidget)self)->xmAnsiTerm.columns = max(1, (((XmAnsiTermWidget)self)->core.width - framewd - 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin)/((XmAnsiTermWidget)self)->xmAnsiTerm.cellwidth);
    ((XmAnsiTermWidget)self)->xmAnsiTerm.rows = max(1, (((XmAnsiTermWidget)self)->core.height - framewd - 2 * ((XmAnsiTermWidget)self)->xmAnsiTerm.margin)/((XmAnsiTermWidget)self)->xmAnsiTerm.cellheight);

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx >= ((XmAnsiTermWidget)self)->xmAnsiTerm.columns) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1;
    if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursory >= ((XmAnsiTermWidget)self)->xmAnsiTerm.rows) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.rows != oldrows || ((XmAnsiTermWidget)self)->xmAnsiTerm.columns != oldcolumns) {
	allocate_contents(self);
	cb_info.rows = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows;
	cb_info.columns = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns;
	XtCallCallbackList(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.resizeCallback, &cb_info);
    }
}
#line 410 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 410 "XmATerm.w"
static void destroy(Widget self)
#else
#line 410 "XmATerm.w"
static void destroy(self)Widget self;
#endif
#line 411 "XmATerm.w"
{
    int i;

    if (((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows != 0) {
	for (i = 0; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.allocated_rows; i++) {
	    XtFree(((XmAnsiTermWidget)self)->xmAnsiTerm.contents[i]);
	    XtFree(((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i]);
	}
	XtFree((char *) ((XmAnsiTermWidget)self)->xmAnsiTerm.contents);
	XtFree((char *) ((XmAnsiTermWidget)self)->xmAnsiTerm.attribs);
    }
    XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.gc);
    XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.boldgc);
    XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.revgc);
    XtReleaseGC(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.revboldgc);
    XFreeFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.fnt);
    XFreeFont(XtDisplay(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.boldfont);
}
#line 439 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 439 "XmATerm.w"
static void expose(Widget self,XEvent * event,Region  region)
#else
#line 439 "XmATerm.w"
static void expose(self,event,region)Widget self;XEvent * event;Region  region;
#endif
#line 440 "XmATerm.w"
{
    int top, bot, lft, rgt, framewd, i;
    XExposeEvent *ev = (XExposeEvent *) event;
    
    if (! XtIsRealized(self)) return;

    framewd = compute_framewd(self);
    if (! event) {
	top = 0;  bot = ((XmAnsiTermWidget)self)->xmAnsiTerm.rows - 1;
	lft = 0;  rgt = ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1;
    } else {
	find_cell(self, framewd, ev->x, ev->y, &lft, &top);
	find_cell(self, framewd, ev->x+ev->width, ev->y + ev->height, &rgt, &bot);
    }
    if (lft < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns && top < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows)
	for (i = top; i <= bot; i++) draw_line(self, framewd, i, lft, rgt + 1);

    /* Plus highlight border (inherited methods) */
    if (((XmAnsiTermWidget)self)->xmPrimitive.highlighted)
	((XmAnsiTermWidgetClass)self->core.widget_class)->xmPrimitive_class.border_highlight(self);
    else
	((XmAnsiTermWidgetClass)self->core.widget_class)->xmPrimitive_class.border_unhighlight(self);
}
#line 484 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 484 "XmATerm.w"
static void write(Widget self,char * text,int  n)
#else
#line 484 "XmATerm.w"
static void write(self,text,n)Widget self;char * text;int  n;
#endif
#line 485 "XmATerm.w"
{
    int framewd, i;

    for (i = 0; i < n; i++) {
        switch (((XmAnsiTermWidget)self)->xmAnsiTerm.state) {
        case Init:
            switch (text[i]) {
            case '\007': XBell(XtDisplay(self), 0); break; /* Bell */
            case '\015': ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = 0; break;	/* CR */
            case '\011': next_tabstop(self); break; /* Tab */
            case '\012': cursor_down(self); break;	/* LF */
            case '\010': if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx--; break; /* Backspace */
            case '\033': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Esc; break;	/* Esc */
            default: add_char(self, text[i]);
            }
            break;
        case Esc:
            switch (text[i]) {
            case '[': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = EscLB; break;
	    case '2': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;	/* Set tab stop ignored */
	    case '7':
		((XmAnsiTermWidget)self)->xmAnsiTerm.savedx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx;
		((XmAnsiTermWidget)self)->xmAnsiTerm.savedy = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case '8': goto_xy(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.savedx, ((XmAnsiTermWidget)self)->xmAnsiTerm.savedy); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
            default:                            /* Unrecognized sequence */
                add_char(self, '\033');
                add_char(self, text[i]);
                ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
            }
	    break;
	case EscLB:
	    switch (text[i]) {
	    case 'H': ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'J': clear_eos(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'K': clear_eol(self), ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] = text[i] - '0';
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Register0;
		break;
	    case 'C': 
		if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx < ((XmAnsiTermWidget)self)->xmAnsiTerm.columns - 1) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx++;
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case 'A': if (((XmAnsiTermWidget)self)->xmAnsiTerm.cursory) ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory--; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'P': delete_char(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'M': delete_line(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'm': ((XmAnsiTermWidget)self)->xmAnsiTerm.cur_attrib = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case '@': insert_chars(self, 1); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'L': insert_line(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case '>': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = EscLBGT; break;
	    case 's':
		((XmAnsiTermWidget)self)->xmAnsiTerm.savedx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx;
		((XmAnsiTermWidget)self)->xmAnsiTerm.savedy = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory;
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case 'u': goto_xy(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.savedx, ((XmAnsiTermWidget)self)->xmAnsiTerm.savedy); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'r': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default:				/* Unrecognized sequence */
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, text[i]);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
	    }
		break;
	case Register0:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] = 10 * ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] + text[i] - '0';
		break;
	    case ';': ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[1] = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Register1; break;
	    case 'm': set_attrib(self, 1); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'h': ((XmAnsiTermWidget)self)->xmAnsiTerm.insert_mode = TRUE; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'l': ((XmAnsiTermWidget)self)->xmAnsiTerm.insert_mode = FALSE; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case '@': insert_chars(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0]); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'b': repeat_char(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] - 1); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'H': case 'f':
                goto_xy(self, 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] - 1);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case 'n': report_cursor_pos(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'j':
		((XmAnsiTermWidget)self)->xmAnsiTerm.cursorx = ((XmAnsiTermWidget)self)->xmAnsiTerm.cursory = 0;
		clear_eos(self);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case 'r': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default: ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register1:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[1] = 10 * ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[1] + text[i] - '0';
		break;
	    case ';': ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[2] = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Register2; break;
	    case 'm': set_attrib(self, 2); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'H': case 'f':
                goto_xy(self, ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[1] - 1, ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[0] - 1);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
		break;
	    case 'r': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;	/* Set scroll region ignored */
	    default: ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register2:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[2] = 10 * ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[2] + text[i] - '0';
		break;
	    case ';': ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[3] = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Register3; break;
	    case 'm': set_attrib(self, 3); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    default: ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register3:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[3] = 10 * ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[3] + text[i] - '0';
		break;
	    case ';': ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[4] = 0; ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Register4; break;
	    case 'm': set_attrib(self, 4); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    default: ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case Register4:
	    switch (text[i]) {
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
		((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[4] = 10 * ((XmAnsiTermWidget)self)->xmAnsiTerm.escparm[4] + text[i] - '0';
		break;
	    case 'm': set_attrib(self, 5); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    default: ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;		/* Ignore unknown sequence */
	    }
	    break;
	case EscLBGT:				/* Seen \E[> */
	    switch (text[i]) {
	    case '2': ((XmAnsiTermWidget)self)->xmAnsiTerm.state = EscLBGT2; break;
	    default:
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, '>');
		add_char(self, text[i]);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
	    }
	    break;
	case EscLBGT2:				/* Seen \E[>2 */
	    switch (text[i]) {
	    case 'h': memory_lock(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    case 'l': memory_unlock(self); ((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init; break;
	    default:
		add_char(self, '\033');
		add_char(self, '[');
		add_char(self, '>');
		add_char(self, '2');
		add_char(self, text[i]);
		((XmAnsiTermWidget)self)->xmAnsiTerm.state = Init;
	    }
		break;
	default:
	    assert(! "Cannot happen");
	}
    }

    /* Finally redraw all lines that are marked as `dirty' */
    if (XtIsRealized(self)) {
	framewd = compute_framewd(self);
	for (i = 0; i < ((XmAnsiTermWidget)self)->xmAnsiTerm.rows; i++)
	    if (((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][0] & ATTRIB_DIRTY) {
		((XmAnsiTermWidget)self)->xmAnsiTerm.attribs[i][0] &= ~ATTRIB_DIRTY;
		draw_line(self, framewd, i, 0, ((XmAnsiTermWidget)self)->xmAnsiTerm.columns);
	    }
	do toggle_cursor(self); while (! ((XmAnsiTermWidget)self)->xmAnsiTerm.cursor_on);
    }
}
#line 111 "XmATerm.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 111 "XmATerm.w"
void  XfwfAnsiWrite(Widget self,char * buf,int  nbytes)
#else
#line 111 "XmATerm.w"
void  XfwfAnsiWrite(self,buf,nbytes)Widget self;char * buf;int  nbytes;
#endif
#line 112 "XmATerm.w"
{
    if (! XtIsSubclass(self, xmAnsiTermWidgetClass))
	XtAppError(XtWidgetToApplicationContext(self),
		   "XfwfAnsiWrite may only be called for AnsiTerm widgets.");
    ((XmAnsiTermWidgetClass)self->core.widget_class)->xmAnsiTerm_class.write(self, buf, nbytes);
}
#line 122 "XmATerm.w"

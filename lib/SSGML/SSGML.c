/* Generated by wbuild from "SSGML.w"
** (generator version $Revision$ of $Date$)
*/
#include <X11/IntrinsicP.h>
#include <X11/StringDefs.h>
#line 2183 "SSGML.w"
#include <X11/Xmu/Converters.h>
#line 2184 "SSGML.w"
#include <ctype.h>
#line 2185 "SSGML.w"
#include <assert.h>
#line 2186 "SSGML.w"
#include <stdio.h>
#line 2187 "SSGML.w"
#include <X11/Xmu/CharSet.h>
#line 2188 "SSGML.w"
#include <regex.h>
#line 2189 "SSGML.w"
#include <X11/xpm.h>
#include <Xfwf/SSGMLP.h>

static char defaultTranslations[] = "\
<Btn1Down>,<Btn1Up>: activate() \n\
<Motion>: motion() \n\
";
static void _resolve_inheritance(
#if NeedFunctionPrototypes
WidgetClass
#endif
);
#line 189 "SSGML.w"
static void class_initialize(
#if NeedFunctionPrototypes
void
#endif
);
#line 196 "SSGML.w"
static void initialize(
#if NeedFunctionPrototypes
Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 214 "SSGML.w"
static Boolean  set_values(
#if NeedFunctionPrototypes
Widget ,Widget ,Widget,ArgList ,Cardinal *
#endif
);
#line 223 "SSGML.w"
static void destroy(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 247 "SSGML.w"
static void pop_style(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 346 "SSGML.w"
static void make_child_from_source(
#if NeedFunctionPrototypes
Widget,Widget ,const  String 
#endif
);
#line 367 "SSGML.w"
static Bool  scan_num(
#if NeedFunctionPrototypes
char *,char *,int *
#endif
);
#line 377 "SSGML.w"
static void push_style(
#if NeedFunctionPrototypes
Widget,XrmQuark ,Attrib 
#endif
);
#line 987 "SSGML.w"
static Bool  get_entity(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal ,char  val[],Cardinal ,int *
#endif
);
#line 1018 "SSGML.w"
static void process_entity(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal 
#endif
);
#line 1073 "SSGML.w"
static void add_endtag(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal 
#endif
);
#line 1100 "SSGML.w"
static void add_starttag(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal ,Attrib 
#endif
);
#line 1108 "SSGML.w"
static void add_text(
#if NeedFunctionPrototypes
Widget,const  char *,Cardinal 
#endif
);
#line 1130 "SSGML.w"
static Bool  get_attrib(
#if NeedFunctionPrototypes
Widget,Attrib ,const  String ,char  value[],Cardinal 
#endif
);
#line 1179 "SSGML.w"
#define new(p) ((p )=(XtPointer )XtMalloc (sizeof (*(p ))))


#line 1180 "SSGML.w"
#define dispose(p) (XtFree ((String )p ),(p )=NULL )


#line 1181 "SSGML.w"
#define newarray(p, n) ((p )=(XtPointer )XtMalloc ((n )*sizeof (*(p ))))


#line 1182 "SSGML.w"
#define renewarray(p, n) ((p )=(XtPointer )XtRealloc ((String )p ,(n )*sizeof (*(p ))))


#line 1183 "SSGML.w"
#define min(a, b) ((a )<(b )?(a ):(b ))


#line 1184 "SSGML.w"
#define max(a, b) ((a )>(b )?(a ):(b ))


#line 1185 "SSGML.w"
#define round(f) ((int )((f )+0.5 ))


#line 1186 "SSGML.w"
#define STRLEN(s) ((s )?strlen (s ):0 )


#line 1192 "SSGML.w"
static XrmQuark  QANCHOR;
#line 1192 "SSGML.w"
static XrmQuark  QBOLD;
#line 1193 "SSGML.w"
static XrmQuark  QDEPTH;
#line 1193 "SSGML.w"
static XrmQuark  QEMPHASIS;
#line 1194 "SSGML.w"
static XrmQuark  QEMPTY;
#line 1194 "SSGML.w"
static XrmQuark  QFAMILY;
#line 1195 "SSGML.w"
static XrmQuark  QFLUSH;
#line 1195 "SSGML.w"
static XrmQuark  QHEIGHT;
#line 1196 "SSGML.w"
static XrmQuark  QHIDE;
#line 1196 "SSGML.w"
static XrmQuark  QHMARGIN;
#line 1197 "SSGML.w"
static XrmQuark  QID;
#line 1197 "SSGML.w"
static XrmQuark  QINLINE;
#line 1198 "SSGML.w"
static XrmQuark  QINSAFTER;
#line 1198 "SSGML.w"
static XrmQuark  QINSBEFORE;
#line 1199 "SSGML.w"
static XrmQuark  QISMAP;
#line 1199 "SSGML.w"
static XrmQuark  QJUSTIFY;
#line 1200 "SSGML.w"
static XrmQuark  QLABEL;
#line 1200 "SSGML.w"
static XrmQuark  QLEADING;
#line 1201 "SSGML.w"
static XrmQuark  QLINDENT;
#line 1201 "SSGML.w"
static XrmQuark  QNOINDENT;
#line 1202 "SSGML.w"
static XrmQuark  QNOWRAP;
#line 1202 "SSGML.w"
static XrmQuark  QOBEYSP;
#line 1203 "SSGML.w"
static XrmQuark  QPARINDENT;
#line 1203 "SSGML.w"
static XrmQuark  QPOSTBREAK;
#line 1204 "SSGML.w"
static XrmQuark  QPREBREAK;
#line 1204 "SSGML.w"
static XrmQuark  QRAISE;
#line 1205 "SSGML.w"
static XrmQuark  QRINDENT;
#line 1205 "SSGML.w"
static XrmQuark  QRULEAFTER;
#line 1206 "SSGML.w"
static XrmQuark  QRULEBEFORE;
#line 1206 "SSGML.w"
static XrmQuark  QSAVECONT;
#line 1207 "SSGML.w"
static XrmQuark  QSIZE;
#line 1208 "SSGML.w"
static XrmQuark  QSLANT;
#line 1208 "SSGML.w"
static XrmQuark  QSTRIKE;
#line 1209 "SSGML.w"
static XrmQuark  QSTYLESHEET;
#line 1209 "SSGML.w"
static XrmQuark  QTARGET;
#line 1210 "SSGML.w"
static XrmQuark  QTEXTBG;
#line 1210 "SSGML.w"
static XrmQuark  QTEXTCOLOR;
#line 1211 "SSGML.w"
static XrmQuark  QTEXTWIDTH;
#line 1211 "SSGML.w"
static XrmQuark  QTILE;
#line 1212 "SSGML.w"
static XrmQuark  QTITLE;
#line 1212 "SSGML.w"
static XrmQuark  QTRACK;
#line 1213 "SSGML.w"
static XrmQuark  QUSCORE;
#line 1213 "SSGML.w"
static XrmQuark  QVALIGN;
#line 1214 "SSGML.w"
static XrmQuark  QVMARGIN;
#line 1214 "SSGML.w"
static XrmQuark  QWIDTH;
#line 1218 "SSGML.w"
static XrmQuark  PCDATA_TAG;
#line 1222 "SSGML.w"
static void init_style_quarks(
#if NeedFunctionPrototypes
void
#endif
);
#line 1277 "SSGML.w"
typedef struct {
	    XrmQuark q;				/* The name as a quark */
	    String name;			/* The name, without "&;" */
	    String value;			/* Replacement text */
	    int charset;			/* Charset or SYSTEM_DATA */
	} EntityRec;
#line 1284 "SSGML.w"
static EntityRec  entities[] = {
	    /* ISOlat1 */
	    {0, "aacute",	"\341",	ISO8859_1},
	    {0, "Aacute",	"\301",	ISO8859_1},
	    {0, "acirc",	"\342",	ISO8859_1},
	    {0, "Acirc",	"\302",	ISO8859_1},
	    {0, "agrave",	"\340",	ISO8859_1},
	    {0, "Agrave",	"\300",	ISO8859_1},
	    {0, "aring",	"\345",	ISO8859_1},
	    {0, "Aring",	"\300",	ISO8859_1},
	    {0, "atilde",	"\343",	ISO8859_1},
	    {0, "Atilde",	"\303",	ISO8859_1},
	    {0, "auml",	 	"\344",	ISO8859_1},
	    {0, "Auml",	 	"\304",	ISO8859_1},
	    {0, "aelig",	"\346",	ISO8859_1},
	    {0, "AElig",	"\306",	ISO8859_1},
	    {0, "ccedil",	"\347",	ISO8859_1},
	    {0, "Ccedil",	"\307",	ISO8859_1},
	    {0, "eth",		"\360",	ISO8859_1},
	    {0, "ETH",		"\320",	ISO8859_1},
	    {0, "eacute",	"\351",	ISO8859_1},
	    {0, "Eacute",	"\311",	ISO8859_1},
	    {0, "ecirc",	"\352",	ISO8859_1},
	    {0, "Ecirc",	"\312",	ISO8859_1},
	    {0, "egrave",	"\350",	ISO8859_1},
	    {0, "Egrave",	"\310",	ISO8859_1},
	    {0, "euml",		"\353",	ISO8859_1},
	    {0, "Euml",		"\313",	ISO8859_1},
	    {0, "iacute",	"\355",	ISO8859_1},
	    {0, "Iacute",	"\315",	ISO8859_1},
	    {0, "icirc",	"\356",	ISO8859_1},
	    {0, "Icirc",	"\316",	ISO8859_1},
	    {0, "igrave",	"\354",	ISO8859_1},
	    {0, "Igrave",	"\314",	ISO8859_1},
	    {0, "iuml",		"\357",	ISO8859_1},
	    {0, "Iuml",		"\317",	ISO8859_1},
	    {0, "ntilde",	"\361",	ISO8859_1},
	    {0, "Ntilde",	"\321",	ISO8859_1},
	    {0, "oacute",	"\363",	ISO8859_1},
	    {0, "Oacute",	"\323",	ISO8859_1},
	    {0, "ocirc",	"\364",	ISO8859_1},
	    {0, "Ocirc",	"\324",	ISO8859_1},
	    {0, "ograve",	"\362",	ISO8859_1},
	    {0, "Ograve",	"\322",	ISO8859_1},
	    {0, "oslash",	"\370",	ISO8859_1},
	    {0, "Oslash",	"\330",	ISO8859_1},
	    {0, "otilde",	"\365",	ISO8859_1},
	    {0, "Otilde",	"\325",	ISO8859_1},
	    {0, "ouml",		"\366",	ISO8859_1},
	    {0, "Ouml",		"\326",	ISO8859_1},
	    {0, "szlig",	"\337",	ISO8859_1},
	    {0, "thorn",	"\376",	ISO8859_1},
	    {0, "THORN",	"\336",	ISO8859_1},
	    {0, "uacute",	"\372",	ISO8859_1},
	    {0, "Uacute",	"\332",	ISO8859_1},
	    {0, "ucirc",	"\373",	ISO8859_1},
	    {0, "Ucirc",	"\333",	ISO8859_1},
	    {0, "ugrave",	"\371",	ISO8859_1},
	    {0, "Ugrave",	"\331",	ISO8859_1},
	    {0, "uuml",		"\374",	ISO8859_1},
	    {0, "Uuml",		"\334",	ISO8859_1},
	    {0, "yacute",	"\375",	ISO8859_1},
	    {0, "Yacute",	"\335",	ISO8859_1},
	    {0, "yuml",		"\377",	ISO8859_1},
	    /* ISOnum */
	    {0, "half",		"\275",	ISO8859_1},
	    {0, "frac12",	"\275",	ISO8859_1},
	    {0, "frac14",	"\274",	ISO8859_1},
	    {0, "frac34",	"\276",	ISO8859_1},
	    {0, "sup1",		"\271",	ISO8859_1},
	    {0, "sup2",		"\262",	ISO8859_1},
	    {0, "sup3",		"\263",	ISO8859_1},
	    {0, "plus",		"+",	ISO8859_1},
	    {0, "plusmn",	"\261",	ISO8859_1},
	    {0, "lt",		"<",	ISO8859_1},
	    {0, "equals",	"=",	ISO8859_1},
	    {0, "gt",		">",	ISO8859_1},
	    {0, "divide",	"\270",	SYMBOLS},
	    {0, "times",	"\264",	SYMBOLS},
	    {0, "curren",	"\244",	ISO8859_1},
	    {0, "pound",	"\243",	ISO8859_1},
	    {0, "dollar",	"$",	ISO8859_1},
	    {0, "cent",		"\242",	ISO8859_1},
	    {0, "yen",		"\245",	ISO8859_1},
	    {0, "num",		"#",	ISO8859_1},
	    {0, "percnt",	"%",	ISO8859_1},
	    {0, "amp",		"&",	ISO8859_1},
	    {0, "ast",		"*",	ISO8859_1},
	    {0, "commat",	"@",	ISO8859_1},
	    {0, "lsqb",		"[",	ISO8859_1},
	    {0, "bsol",		"\\",	ISO8859_1},
	    {0, "rsqb",		"]",	ISO8859_1},
	    {0, "lcub",		"{",	ISO8859_1},
	    {0, "horbar",	"\276",	SYMBOLS},
	    {0, "verbar",	"|",	ISO8859_1},
	    {0, "rcub",		"}",	ISO8859_1},
	    {0, "micro",	"\265",	ISO8859_1},
	    {0, "ohm",		"\127", SYMBOLS},
	    {0, "deg",		"\260",	ISO8859_1},
	    /*  "ordm",		"???",	ISO8859_1 */
	    /*  "ordf",		"???",	ISO8859_1 */
	    {0, "sect",		"\246",	ISO8859_1},
	    {0, "para",		"\266",	ISO8859_1},
	    {0, "middot",	"\267",	ISO8859_1},
	    {0, "larr",		"\254",	SYMBOLS},
	    {0, "rarr",		"\256",	SYMBOLS},
	    {0, "uarr",		"\255",	SYMBOLS},
	    {0, "darr",		"\257",	SYMBOLS},
	    {0, "copy",		"\251",	ISO8859_1},
	    {0, "reg",		"\256",	ISO8859_1},
	    {0, "trade",	"\324",	SYMBOLS},
	    {0, "brvbar",	"\245",	ISO8859_1},
	    {0, "not",		"\254",	ISO8859_1},
	    /*  "sung",		"???",	ISO8859_1 */
	    {0, "excl",		"!",	ISO8859_1},
	    {0, "iexcl",	"\240",	ISO8859_1},
	    {0, "quot",		"\"",	ISO8859_1},
	    {0, "apos",		"\264",	ISO8859_1},
	    {0, "lpar",		"(",	ISO8859_1},
	    {0, "rpar",		")",	ISO8859_1},
	    {0, "comma",	",",	ISO8859_1},
	    {0, "lowbar",	"_",	ISO8859_1},
	    {0, "hyphen",	"-",	ISO8859_1},
	    {0, "period",	".",	ISO8859_1},
	    {0, "sol",		"/",	ISO8859_1},
	    {0, "colon",	":",	ISO8859_1},
	    {0, "semi",		";",	ISO8859_1},
	    {0, "quest",	"?",	ISO8859_1},
	    {0, "iquest",	"\277",	ISO8859_1},
	    {0, "laquo",	"\341",	SYMBOLS},
	    {0, "raquo",	"\361",	SYMBOLS},
	    {0, "lsquo",	"`",	ISO8859_1},
	    {0, "rsquo",	"'",	ISO8859_1},
	    {0, "ldquo",	"``",	ISO8859_1},
	    {0, "rdquo",	"''",	ISO8859_1},
	    {0, "nbsp",		"nbsp",	SYSTEM_DATA}, /* No break space */
	    {0, "shy",		"",	SYSTEM_DATA}, /* Soft hyphen */
	    /* ISOgrk3 */
	    {0, "alpha",	"a",	SYMBOLS},
	    {0, "beta",		"b",	SYMBOLS},
	    {0, "gamma",	"g",	SYMBOLS},
	    {0, "Gamma",	"G",	SYMBOLS},
	    /*  "gammad",	"",	SYMBOLS */
	    {0, "delta",	"d",	SYMBOLS},
	    {0, "Delta",	"D",	SYMBOLS},
	    {0, "epsi",		"e",	SYMBOLS},
	    {0, "epsiv",	"\316",	SYMBOLS},
	    /*  "epsis",	"",	SYMBOLS */
	    {0, "zeta",		"z",	SYMBOLS},
	    {0, "eta",		"h",	SYMBOLS},
	    {0, "thetas",	"q",	SYMBOLS},
	    {0, "Theta",	"Q",	SYMBOLS},
	    {0, "thetav",	"J",	SYMBOLS},
	    {0, "iota",		"i",	SYMBOLS},
	    {0, "kappa",	"k",	SYMBOLS},
	    /*  "kappav",	"",	SYMBOLS */
	    {0, "lambda",	"l",	SYMBOLS},
	    {0, "Lambda",	"L",	SYMBOLS},
	    {0, "mu",		"m",	SYMBOLS},
	    {0, "nu",		"n",	SYMBOLS},
	    {0, "xi",		"x",	SYMBOLS},
	    {0, "Xi",		"X",	SYMBOLS},
	    {0, "pi",		"p",	SYMBOLS},
	    /*  "piv",		"",	SYMBOLS */
	    {0, "Pi",		"P",	SYMBOLS},
	    {0, "rho",		"r",	SYMBOLS},
	    /*  "rhov",		"",	SYMBOLS */
	    {0, "sigma",	"s",	SYMBOLS},
	    {0, "Sigma",	"S",	SYMBOLS},
	    {0, "sigmav",	"V",	SYMBOLS},
	    {0, "tau",		"t",	SYMBOLS},
	    {0, "upsi",		"u",	SYMBOLS},
	    {0, "Upsi",		"U",	SYMBOLS},
	    {0, "phis",		"f",	SYMBOLS},
	    {0, "Phi",		"F",	SYMBOLS},
	    {0, "phiv",		"j",	SYMBOLS},
	    {0, "chi",		"c",	SYMBOLS},
	    {0, "psi",		"y",	SYMBOLS},
	    {0, "Psi",		"Y",	SYMBOLS},
	    {0, "omega",	"w",	SYMBOLS},
	    {0, "Omega",	"W",	SYMBOLS},
	    /* ISOtech */
	    {0, "aleph",	"\300", SYMBOLS},
	    {0, "and",		"\331", SYMBOLS},
	    /*  "ang90",	"", SYMBOLS */
	    /*  "angsph",	"", SYMBOLS */
	    {0, "ap",		"\273", SYMBOLS},
	    {0, "becaus",	"\334", SYMBOLS},
	    {0, "bottom",	"\136", SYMBOLS},
	    {0, "cap",		"\307", SYMBOLS},
	    /*  "cong",		"", SYMBOLS */
	    /*  "conint",	"", SYMBOLS */
	    {0, "cup",		"\254", SYMBOLS},
	    {0, "equiv",	"\272", SYMBOLS},
	    {0, "exist",	"\44", SYMBOLS},
	    {0, "forall",	"\42", SYMBOLS},
	    {0, "fnof",		"\246", SYMBOLS},
	    {0, "ge",		"\263", SYMBOLS},
	    {0, "iff",		"\333", SYMBOLS},
	    {0, "infin",	"\245", SYMBOLS},
	    {0, "int",		"\362", SYMBOLS},
	    {0, "isin",		"\316", SYMBOLS},
	    {0, "lang",		"\341", SYMBOLS},
	    {0, "lArr",		"\334", SYMBOLS},
	    {0, "le",		"\243", SYMBOLS},
	    {0, "minus",	"-", SYMBOLS},
	    /*  "mnplus",	"", SYMBOLS */
	    {0, "nabla",	"\321", SYMBOLS},
	    {0, "ne",		"\271", SYMBOLS},
	    {0, "ni",		"\314", SYMBOLS},
	    {0, "or",		"\332", SYMBOLS},
	    /*  "par",		"", SYMBOLS */
	    {0, "part",		"\266", SYMBOLS},
	    /*  "permil",	"", SYMBOLS */
	    {0, "perp",		"\136", SYMBOLS},
	    {0, "prime",	"\242", SYMBOLS},
	    {0, "Prime",	"\262", SYMBOLS},
	    {0, "prop",		"\265", SYMBOLS},
	    /*  "radic",	"", SYMBOLS */
	    {0, "rang",		"\361", SYMBOLS},
	    {0, "rArr",		"\336", SYMBOLS},
	    {0, "sim",		"\176", SYMBOLS},
	    /*  "sime",		"", SYMBOLS */
	    /*  "square",	"", SYMBOLS */
	    {0, "sub",		"\314", SYMBOLS},
	    {0, "sube",		"\315", SYMBOLS},
	    {0, "sup",		"\311", SYMBOLS},
	    {0, "supe",		"\312", SYMBOLS},
	    /*  "there4",	"", SYMBOLS */
	    {0, "Verbar",	"||", SYMBOLS},
	    {0, "angst",	"\305", ISO8859_1},
	    /*  "bernou",	"", SYMBOLS */
	    /*  "compfn",	"", SYMBOLS */
	    /*  "Dot",		"", SYMBOLS */
	    /*  "DotDot",	"", SYMBOLS */
	    /*  "hamilt",	"", SYMBOLS */
	    /*  "lagran",	"", SYMBOLS */
	    {0, "lowast",	"*", SYMBOLS},
	    {0, "notin",	"\317", SYMBOLS},
	    /*  "order",	"", SYMBOLS */
	    /*  "phmmat",	"", SYMBOLS */
	    /*  "tdot",		"", SYMBOLS */
	    /*  "tprime",	"", SYMBOLS */
	    /*  "wedgeq",	"", SYMBOLS */
	    /* ... */
	    {0, "bull",		"\267",	SYMBOLS},
	    {0, "mdash",	"\276",	SYMBOLS},
	    {0, "ndash",	"\276",	SYMBOLS},
	    {0, "harr",		"\253",	SYMBOLS},
	    {0, "uArr",		"\335",	SYMBOLS},
	    {0, "dArr",		"\337",	SYMBOLS},
	    /* ... */
	};
#line 1538 "SSGML.w"
static void init_entity_quarks(
#if NeedFunctionPrototypes
void
#endif
);
#line 1550 "SSGML.w"
static void init_stystack(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1593 "SSGML.w"
#define CHK_SAVE_CONTENT(sty, data, len) do {\
        if ((sty)->save_content) {\
	    if (! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer) {\
		newarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer, (len) + 1);\
		((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer[0] = '\0';\
	    } else\
		renewarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer, strlen(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer) + (len) + 1);\
	    strncat(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer, data, len);\
	}\
    }while (0 )


#line 1608 "SSGML.w"
static void add_word(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal ,Pixel ,Pixel ,TextStyle ,int ,XtPointer 
#endif
);
#line 1655 "SSGML.w"
static void add_spaces(
#if NeedFunctionPrototypes
Widget,const  String ,Cardinal 
#endif
);
#line 1709 "SSGML.w"
static void add_newline(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1736 "SSGML.w"
static void add_eod(
#if NeedFunctionPrototypes
Widget
#endif
);
#line 1747 "SSGML.w"
static Bool  interp_ifmatch(
#if NeedFunctionPrototypes
Widget,char *,Attrib ,char  t[]
#endif
);
#line 1832 "SSGML.w"
static Bool  get_property(
#if NeedFunctionPrototypes
Widget,XrmSearchList ,Attrib ,XrmQuark ,char  val[]
#endif
);
#line 1860 "SSGML.w"
static void tag_nesting_to_quarklist(
#if NeedFunctionPrototypes
Widget,XrmQuark  nest[TAGLVL]
#endif
);
#line 1876 "SSGML.w"
static String  upper(
#if NeedFunctionPrototypes
String 
#endif
);
#line 1893 "SSGML.w"
static void parse_starttag(
#if NeedFunctionPrototypes
Widget,String *,Cardinal *,Attrib *
#endif
);
#line 1966 "SSGML.w"
#define isnmchar(c) (isalpha (c )||(c )=='-'||(c )=='.'||(c )=='_')


#line 1968 "SSGML.w"
static Bool  get_token(
#if NeedFunctionPrototypes
Widget,Bool ,Token *,String *,Cardinal *,Attrib *
#endif
);
#line 2108 "SSGML.w"
static void dispose_attr(
#if NeedFunctionPrototypes
Attrib *
#endif
);
#line 2119 "SSGML.w"
static void parse_text(
#if NeedFunctionPrototypes
Widget,Bool 
#endif
);
#line 2150 "SSGML.w"
static void get_parser_state(
#if NeedFunctionPrototypes
Widget,String *,Cardinal *,Cardinal *
#endif
);
#line 2156 "SSGML.w"
static void set_parser_state(
#if NeedFunctionPrototypes
Widget,String ,Cardinal ,Cardinal 
#endif
);
#line 2166 "SSGML.w"
#define ED_INCR 25 


#line 2168 "SSGML.w"
static int  alloc_extradata(
#if NeedFunctionPrototypes
Widget,char *,Bool 
#endif
);
#line 1222 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1222 "SSGML.w"
static void init_style_quarks(void)
#else
#line 1222 "SSGML.w"
static void init_style_quarks()
#endif
#line 1223 "SSGML.w"
{
    QANCHOR = XrmStringToQuark("anchor");
    QBOLD = XrmStringToQuark("bold");
    QDEPTH = XrmStringToQuark("depth");
    QEMPHASIS = XrmStringToQuark("emphasis");
    QEMPTY = XrmStringToQuark("empty");
    QFAMILY = XrmStringToQuark("family");
    QFLUSH = XrmStringToQuark("flush");
    QHEIGHT = XrmStringToQuark("height");
    QHIDE = XrmStringToQuark("hide");
    QHMARGIN = XrmStringToQuark("hmargin");
    QID = XrmStringToQuark("id");
    QINLINE = XrmStringToQuark("inline");
    QINSAFTER = XrmStringToQuark("insertafter");
    QINSBEFORE = XrmStringToQuark("insertbefore");
    QISMAP = XrmStringToQuark("ismap");
    QJUSTIFY = XrmStringToQuark("justify");
    QLABEL = XrmStringToQuark("label");
    QLEADING = XrmStringToQuark("leading");
    QLINDENT = XrmStringToQuark("leftindent");
    QNOINDENT = XrmStringToQuark("noindent");
    QNOWRAP = XrmStringToQuark("nowrap");
    QOBEYSP = XrmStringToQuark("obeyspaces");
    QPARINDENT = XrmStringToQuark("parindent");
    QPOSTBREAK = XrmStringToQuark("postbreak");
    QPREBREAK = XrmStringToQuark("prebreak");
    QRAISE = XrmStringToQuark("raise");
    QRINDENT = XrmStringToQuark("rightindent");
    QRULEAFTER = XrmStringToQuark("ruleafter");
    QRULEBEFORE = XrmStringToQuark("rulebefore");
    QSAVECONT = XrmStringToQuark("savecontent");
    QSIZE = XrmStringToQuark("size");
    QSLANT = XrmStringToQuark("slant");
    QSTRIKE = XrmStringToQuark("strikeout");
    QSTYLESHEET = XrmStringToQuark("stylesheet");
    QTARGET = XrmStringToQuark("target");
    QTEXTBG = XrmStringToQuark("textbackground");
    QTEXTCOLOR = XrmStringToQuark("textcolor");
    QTEXTWIDTH = XrmStringToQuark("textwidth");
    QTILE = XrmStringToQuark("tile");
    QTITLE = XrmStringToQuark("title");
    QTRACK = XrmStringToQuark("track");
    QUSCORE = XrmStringToQuark("underscore");
    QVALIGN = XrmStringToQuark("valign");
    QVMARGIN = XrmStringToQuark("vmargin");
    QWIDTH = XrmStringToQuark("width");

    PCDATA_TAG = XrmStringToQuark("#PCDATA");
}
#line 1538 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1538 "SSGML.w"
static void init_entity_quarks(void)
#else
#line 1538 "SSGML.w"
static void init_entity_quarks()
#endif
#line 1539 "SSGML.w"
{
    int i;
    for (i = 0; i < XtNumber(entities); i++)
	entities[i].q = XrmStringToQuark(entities[i].name);
}
#line 1550 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1550 "SSGML.w"
static void init_stystack(Widget self)
#else
#line 1550 "SSGML.w"
static void init_stystack(self)Widget self;
#endif
#line 1551 "SSGML.w"
{
    FormatInfo sty;
    int h, d;

    new(sty);
    sty->next = NULL;
    sty->tag = XrmStringToQuark("<default style>");
    sty->verbatim = FALSE;
    sty->nowrap = FALSE;
    sty->textstyle = FtNORMALSIZE | FtFAMILY1;
    sty->fg = ((XfwfSimpleSGMLWidget)self)->xmManager.foreground;
    sty->bg = TRANSPARENT;
    sty->hide = FALSE;
    sty->title = FALSE;
    sty->stylesheettype = StyleNo;
    sty->stylesheet = NULL;
    sty->data = 0;				/* --> $extradata[0] = NULL */
    sty->ismap = FALSE;
    sty->inlinehmargin = 0;
    sty->inlinevmargin = 0;
    sty->children = 0;
    sty->break_after = FALSE;
    sty->parmode = FtJUSTIFYBOTH | FtNORMALPARA | FtNOCLEAR;
    sty->leftmargin = 0;
    sty->rightmargin = 0;
    sty->width = -1;
    sty->leading = 1.0;
    sty->flush = FtNOCLEAR;
    sty->parindent = 0;
    sty->suppress_indent = FALSE;
    sty->save_content = FALSE;

    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack = sty;

    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em = ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.get_em_of_textstyle(self, sty->textstyle);
    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.get_lineheight_of_textstyle(self, sty->textstyle, &h, &d);
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline = h + d;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.suppress_indent = FALSE;
}
#line 1608 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1608 "SSGML.w"
static void add_word(Widget self,const  String  data,Cardinal  len,Pixel  fg,Pixel  bg,TextStyle  style,int  parindent,XtPointer  extra)
#else
#line 1608 "SSGML.w"
static void add_word(self,data,len,fg,bg,style,parindent,extra)Widget self;const  String  data;Cardinal  len;Pixel  fg;Pixel  bg;TextStyle  style;int  parindent;XtPointer  extra;
#endif
#line 1609 "SSGML.w"
{
    int w, sp;
    FormatInfo sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;

    if (sty->title) {				/* Current elt is a title */
	if (! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title) {
	    newarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title, len + 1);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title[0] = '\0';
	} else
	    renewarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title, strlen(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title) + len + 1);
	strncat(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title, data, len);
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->stylesheettype != StyleNo) { /* Current is stylesheet */
	if (! sty->stylesheet) {
	    newarray(sty->stylesheet, len + 1);
	    sty->stylesheet[0] = '\0';
	} else
	    renewarray(sty->stylesheet, strlen(sty->stylesheet) + len + 1);
	strncat(sty->stylesheet, data, len);
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->hide) {			/* Current element is hidden */
	CHK_SAVE_CONTENT(sty, data, len);
	/* Do nothing */
    } else if (sty->tag != PCDATA_TAG) {	/* Start PCDATA first */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_starttag(self, "#PCDATA", 7, NULL);	/* Then recurse */
	add_word(self, data, len, fg, bg, style, parindent, extra);
    } else {					/* Normal word, create chunk */
	if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par) {			/* New paragraph */
	    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.suppress_indent) {		/* No indent */
		((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.suppress_indent = FALSE;	/* Reset for next par */
	    } else if (parindent != 0) {	/* Insert parindent */
		sp = ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.get_space_of_textstyle(self, style);
		w = 1000 * parindent/sp;
		((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, w, FALSE, FALSE, fg, bg, style, extra);
	    }
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = FALSE;
	}
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_word(self, data, len, fg, bg, style, extra);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = FALSE;
	CHK_SAVE_CONTENT(sty, data, len);
    }
}
#line 1655 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1655 "SSGML.w"
static void add_spaces(Widget self,const  String  data,Cardinal  len)
#else
#line 1655 "SSGML.w"
static void add_spaces(self,data,len)Widget self;const  String  data;Cardinal  len;
#endif
#line 1656 "SSGML.w"
{
    FormatInfo sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;

    if (sty->title) {				/* Store in title */
	if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title) {				/* Don't add spaces at start */
	    renewarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title, strlen(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title) + len + 2);
	    strncat(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title, data, len);
	}
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->stylesheettype != StyleNo) { /* Store in stylesheet */
	if (! sty->stylesheet) {
	    newarray(sty->stylesheet, len + 1);
	    sty->stylesheet[0] = '\0';
	} else
	    renewarray(sty->stylesheet, strlen(sty->stylesheet) + len + 2);
	strncat(sty->stylesheet, data, len);
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->hide) {			/* Don't display */
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->verbatim) {			/* As many spaces as in data */
	if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->tag != PCDATA_TAG) {	/* Start PCDATA */
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_starttag(self, "#PCDATA", 7, NULL);
	    add_spaces(self, data, len);		/* Recursively */
	} else {
	    add_word(self, data, len, sty->fg, sty->bg, sty->textstyle,
		     sty->parindent, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	}
    } else if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par) {			/* Ignore space at start */
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank) {		/* Ignore multiple spaces */
	CHK_SAVE_CONTENT(sty, data, len);
    } else if (sty->tag != PCDATA_TAG) {	/* Start PCDATA first */
	add_starttag(self, "#PCDATA", 7, NULL);
	add_spaces(self, data, len);		/* Recursively */
    } else if (sty->nowrap) {			/* No breakable space */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, 1000, TRUE, FALSE, sty->fg, sty->bg,
		    sty->textstyle, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
	CHK_SAVE_CONTENT(sty, data, len);
    } else {
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, 1000, TRUE, TRUE, sty->fg, sty->bg,
		    sty->textstyle, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
	CHK_SAVE_CONTENT(sty, data, len);
    }
}
#line 1709 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1709 "SSGML.w"
static void add_newline(Widget self)
#else
#line 1709 "SSGML.w"
static void add_newline(self)Widget self;
#endif
#line 1710 "SSGML.w"
{
    FormatInfo sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;

    if (sty->title) add_spaces(self, " ", 1);
    else if (sty->stylesheettype != StyleNo) add_spaces(self, "\n", 1);
    else if (sty->hide) {
	CHK_SAVE_CONTENT(sty, "\n", 1);
    } else if (! sty->verbatim) add_spaces(self, " ", 1);
    else {
	if (sty->tag != PCDATA_TAG) {		/* Start PCDATA first */
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_starttag(self, "#PCDATA", 7, NULL);
	    add_newline(self);			/* Recursively */
	} else {
	    /* add_spaces($, " ", 1); */
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_vspace(self, 0);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = FALSE;
	    CHK_SAVE_CONTENT(sty, "\n", 1);
	}
    }
}
#line 1736 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1736 "SSGML.w"
static void add_eod(Widget self)
#else
#line 1736 "SSGML.w"
static void add_eod(self)Widget self;
#endif
#line 1737 "SSGML.w"
{
    while (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->next != NULL) ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.pop_style(self);
    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_eod(self);
}
#line 1747 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1747 "SSGML.w"
static Bool  interp_ifmatch(Widget self,char * s,Attrib  attr,char  t[])
#else
#line 1747 "SSGML.w"
static Bool  interp_ifmatch(self,s,attr,t)Widget self;char * s;Attrib  attr;char  t[];
#endif
#line 1748 "SSGML.w"
{
    char name[LITLEN+1], re[LITLEN+1], val[LITLEN+1];
    Bool in_set, match, is_attr;
    regex_t regex;
    int i, k;

    assert(strncmp(s, "@ifmatch(", 9) == 0);

    /* Get attribute or property name */
    for (i = 9; isspace(s[i]); i++) ;
    if (s[i] == '!') is_attr = TRUE;
    else if (s[i] == '$') is_attr = FALSE;	/* property name */
    else return FALSE;				/* Syntax error */
    for (i++, k = 0; isnmchar(s[i]); i++, k++) name[k] = s[i];
    name[k] = '\0';

    /* Get regular expression */
    for (; isspace(s[i]); i++) ;
    if (s[i] != ',') return FALSE;		/* Syntax error */
    for (i++; isspace(s[i]); i++) ;
    if (s[i] != '"') return FALSE;		/* Syntax error */
    i++;
    in_set = FALSE;
    for (k = 0; s[i] && (s[i] != '"' || in_set); i++, k++) {
        re[k] = s[i];
        if (s[i] == '\\' && s[i+1]) re[++k] = s[++i];
        else if (s[i] == '[') in_set = TRUE;
        else if (s[i] == ']' && s[i-1] != '[') in_set = FALSE;
    }
    re[k] = '\0';
    if (s[i] != '"') return FALSE;		/* Syntax error */

    /* Get attribute/property value and execute regular expression */
    if (! is_attr) {
	XtAppWarning(XtWidgetToApplicationContext(self),
		   "`$property' in stylesheet not implemented yet.");
	match = FALSE;
    } else if (! get_attrib(self, attr, name, val, sizeof(val))) {
	match = FALSE;
    } else if (regcomp(&regex, re, REG_EXTENDED|REG_NOSUB) != 0) {
#if 0
	XtAppWarning(XtWidgetToApplicationContext(self),
		   "Regular expression in stylesheet is incorrect.");
#endif
	return FALSE;
    } else {
	match = regexec(&regex, val, 0, NULL, 0) == 0;
	regfree(&regex);
    }

    /* Skip to "then" part */
    for (i++; isspace(s[i]); i++) ;
    if (s[i] != ',') return FALSE;		/* Syntax error */
    for (i++; isspace(s[i]); i++) ;

    if (match) {
	/* Copy "then" part */
        for (k = 0; s[i] && s[i] != ',' && s[i] != ')'; i++, k++) t[k] = s[i];
        t[k] = '\0';
    } else {
        for (; s[i] && s[i] != ',' && s[i] != ')'; i++) ; /* Skip then-part */
	/* Get "else" part */
	if (!s[i]) return FALSE;		/* Syntax error */
	if (s[i] == ')') return FALSE;		/* Empty else-part */
	for (i++; isspace(s[i]); i++) ;
	for (k = 0; s[i] && s[i] != ')'; i++, k++) t[k] = s[i];
#if 0
	if (!s[i]) return FALSE;		/* Syntax error */
#endif
	t[k] = '\0';
    }
    return TRUE;
}
#line 1832 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1832 "SSGML.w"
static Bool  get_property(Widget self,XrmSearchList  list,Attrib  attr,XrmQuark  property,char  val[])
#else
#line 1832 "SSGML.w"
static Bool  get_property(self,list,attr,property,val)Widget self;XrmSearchList  list;Attrib  attr;XrmQuark  property;char  val[];
#endif
#line 1833 "SSGML.w"
{
    XrmQuark repr;
    XrmValue v2, v1;

    v1.size = LITLEN + 1;
    v1.addr = val;
    v2.addr = NULL;
    if (! XrmQGetSearchResource(list, property, property, &repr, &v2)
	|| ! XtConvertAndStore(self, XrmNameToString(repr), &v2, XtRString, &v1))
	return FALSE;

    /* Evaluate @-functions */
    while (strncmp(val, "@ifmatch(", 9) == 0)
	if (!interp_ifmatch(self, val, attr, val)) return FALSE;

    if (val[0] == '!')
	return get_attrib(self, attr, val + 1, val, LITLEN + 1);
    /* else if (val[0] == '$')
	return get_parent_property($, val + 1, val); */
    else
	return TRUE;
}
#line 1860 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1860 "SSGML.w"
static void tag_nesting_to_quarklist(Widget self,XrmQuark  nest[TAGLVL])
#else
#line 1860 "SSGML.w"
static void tag_nesting_to_quarklist(self,nest)Widget self;XrmQuark  nest[TAGLVL];
#endif
#line 1861 "SSGML.w"
{
    FormatInfo s;
    Cardinal n;

    for (n = 0, s = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack; s->next; s = s->next) n++;
    if (n >= TAGLVL) n = TAGLVL - 1;
    nest[n] = 0;
    for (s = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack; n > 0 && s->next; s = s->next) nest[--n] = s->tag;
    assert(n == 0);

}
#line 1876 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1876 "SSGML.w"
static String  upper(String  s)
#else
#line 1876 "SSGML.w"
static String  upper(s)String  s;
#endif
#line 1877 "SSGML.w"
{
    String t;
    if (s != NULL) for (t = s; *t; t++) *t = _toupper(*t);
    return s;
}
#line 1893 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1893 "SSGML.w"
static void parse_starttag(Widget self,String * name,Cardinal * namelen,Attrib * attr)
#else
#line 1893 "SSGML.w"
static void parse_starttag(self,name,namelen,attr)Widget self;String * name;Cardinal * namelen;Attrib * attr;
#endif
#line 1894 "SSGML.w"
{
    char *s = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text + ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
    int i, j, k;
    Attrib h;

    assert(s[0] == '<');

    /* Get element name */
    i = 1;					/* Skip '<' */
    while (s[i] != '>' && ! isspace(s[i])) i++;
    *namelen = min(i - 1, NAMELEN);		/* Element name */
    *name = s + 1;

    /* Get attributes */
    *attr = NULL;
    while (s[i] != '>') {
	j = i;
	while (isspace(s[j])) j++;
	i = j;
	if (s[i] == '>') break;

	/* Get next attribute name */
	while (isnmchar(s[j])) j++;
	if (j == i) break;			/* Error, ill. char. */
	new(h); h->next = *attr; *attr = h;
	h->name[0] = '\0'; upper(strncat(h->name, s + i, min(j - i, NAMELEN)));

	/* Look for attribute's value */
	k = j;
	while (isspace(s[j])) j++;
	if (s[j] != '=') {			/* No value, use name */
	    strcpy(h->value, h->name);
	    i = j;
	} else {
	    j++;
	    while (isspace(s[j])) j++;
	    i = j;
	    if (s[i] == '>') break;		/* Error, ignore */
	    h->value[0] = '\0';
	    if (s[i] == '"') {			/* Quoted literal */
		j = i + 1;
		while (s[j] != '"' && s[j] != '\n') j++;
		/* \n is incorrect, but we catch unclosed strings... */
		strncat(h->value, s + i + 1, min(j - (i + 1), LITLEN));
		i = j + 1;
	    } else if (s[i] == '\'') {		/* Quoted (') literal */
		j = i + 1;
		while (s[j] != '\'' && s[j] != '\n') j++;
		/* \n is incorrect, but we catch unclosed strings... */
		strncat(h->value, s + i + 1, min(j - (i + 1), LITLEN));
		i = j + 1;
	    } else {				/* Name token */
		while (s[j] != '>' && ! isspace(s[j])) j++;
#if 0
		upper(strncat(h->value, s + i, min(j - i, LITLEN)));
#else
		strncat(h->value, s + i, min(j - i, LITLEN));
#endif
		i = j;
	    }
	}
    }
}
#line 1968 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1968 "SSGML.w"
static Bool  get_token(Widget self,Bool  is_eof,Token * tok,String * data,Cardinal * len,Attrib * attr)
#else
#line 1968 "SSGML.w"
static Bool  get_token(self,is_eof,tok,data,len,attr)Widget self;Bool  is_eof;Token * tok;String * data;Cardinal * len;Attrib * attr;
#endif
#line 1969 "SSGML.w"
{
    char prev, *s = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text;
    Bool com, sq, dq;
    Cardinal i, nbrack;

    assert(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed <= ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars);
    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE;	/* Insufficient data */
    i = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
    *data = s + i;

    switch (s[i]) {

    case '\r':
	*tok = T_NONE;
	i++;
	*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	return TRUE;

    case ' ':
    case '\t':
	while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && (s[i] == ' ' || s[i] == '\t')) i++;
	if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && ! is_eof) return FALSE;
	*tok = T_BLANK;
	*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	return TRUE;

    case '\n':
    case '\f':
	if (i + 1 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && is_eof) *tok = T_NL; /* Nothing follows */
	else if (i + 1 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE; /* Next char unknown */
	else if (s[i+1] != '<') *tok = T_NL;	/* Next is not a tag */
	else if (i + 2 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && is_eof) *tok = T_NL; /* Next not tag */
	else if (i + 2 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE; /* Unknown < or </ */
	else if (s[i+2] == '/') *tok = T_NONE; /* Next is endtag */
	else *tok = T_NL;
	i++;
	*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	return TRUE;

    case '&':
	i++;
	if (s[i] == '#') {
	    if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) {*tok = T_NONE; return is_eof;}
	    i++;
	    while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && isdigit(s[i])) i++;
	} else {
	    while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && isnmchar(s[i])) i++;
	}
	if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && ! is_eof) return FALSE;
	(*data)++;				/* Skip '&' */
	*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed - 1;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && s[i] == ';') ? i + 1 : i;
	*tok = T_ENTITY;
	return TRUE;

    case '<':					/* Markup? */
	if (++i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed) return FALSE;

	switch (s[i]) {

	case '/':				/* Endtag? */
	    while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && s[i] != '>' && ! isspace(s[i])) i++;
	    if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && ! is_eof) {
		return FALSE;			/* Next char unknown */
	    } else if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars || s[i] != '>') {
		*tok = T_WORD;			/* Incomplete tag */
		*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
		((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
		return TRUE;
	    } else {
		assert(s[i] == '>');
		*tok = T_ENDTAG;
		*data += 2;			/* Skip "</" */
		*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed - 2;	/* Length of tag */
		((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i + 1;		/* Skip ">" */
		return TRUE;
	    }

	case '!':
	    prev = '\0';
	    com = dq = sq = FALSE;
	    nbrack = 0;
	    while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && (s[i] != '>' || com || dq || sq || nbrack)) {
		if (s[i] == '"' && !sq && !com) dq = !dq;
		else if (s[i] == '\'' && !dq && !com) sq = !sq;
		else if (s[i] == '-' && !dq && !sq && prev == '-') com = !com;
		else if (s[i] == '<' && !dq && !sq && !com) nbrack++;
		else if (s[i] == '>' && !dq && !sq && !com) nbrack--;
		else if (s[i] == '\n') dq = sq = FALSE;
		/* \n is incorrect, but we catch unclosed strings... */
		prev = prev != '-' ? s[i] : '\0';
		i++;
	    }
	    if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE;
	    *tok = T_NONE;
	    i++;
	    *len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	    return TRUE;

	default:				/* Start tag */
	    dq = sq = FALSE;
	    while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && (s[i] != '>' || dq || sq)) {
		if (s[i] == '"' && !sq) dq = !dq;
		else if (s[i] == '\'' && !dq) sq = !sq;
		else if (s[i] == '\n') dq = sq = FALSE;
		/* \n is incorrect, but we catch unclosed strings... */
		i++;
	    }
	    if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE;	/* No > found yet */
	    else if (i + 1 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && is_eof) ; /* Nothing after > */
	    else if (i + 1 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE; /* Wait for \n */
	    else if (s[i+1] == '\n' || s[i+1] == '\f') i++; /* Skip \n */
	    else if (s[1+1] != '\r') ;		/* Nothing to skip */
	    else if (i + 2 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && is_eof) i++;	/* Skip \r */
	    else if (i + 2 == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars) return FALSE; /* Wait for \n */
	    else if (s[i+2] == '\n' || s[i+2] == '\f') i += 2; /* Skip \r\n */
	    i++;
	    *tok = T_STARTTAG;
	    parse_starttag(self, data, len, attr);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	    return TRUE;
	}

    default:
	while (i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && s[i] != ' ' && s[i] != '\t'
	       && s[i] != '\r' && s[i] != '\n' && s[i] != '\f'
	       && s[i] != '<' && s[i] != '&') i++;
	if (i == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars && ! is_eof) return FALSE;
	*tok = T_WORD;
	*len = i - ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = i;
	return TRUE;
    }
}
#line 2108 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 2108 "SSGML.w"
static void dispose_attr(Attrib * attr)
#else
#line 2108 "SSGML.w"
static void dispose_attr(attr)Attrib * attr;
#endif
#line 2109 "SSGML.w"
{
    if (*attr) {
	dispose_attr(&(*attr)->next);
	dispose(*attr);
    }
}
#line 2119 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 2119 "SSGML.w"
static void parse_text(Widget self,Bool  is_eof)
#else
#line 2119 "SSGML.w"
static void parse_text(self,is_eof)Widget self;Bool  is_eof;
#endif
#line 2120 "SSGML.w"
{
    Token tok;
    String data;
    Cardinal len;
    Attrib attr;

    while (get_token(self, is_eof, &tok, &data, &len, &attr)) {
	switch (tok) {
	case T_WORD:
	    add_word(self, data, len, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->fg, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->bg,
		     ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->textstyle, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->parindent,
		     ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->data]);
	    break;
	case T_BLANK: add_spaces(self, data, len); break;
	case T_NL: add_newline(self); break;
	case T_ENTITY: ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.process_entity(self, data, len); break;
	case T_ENDTAG: ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_endtag(self, data, len); break;
	case T_STARTTAG:
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_starttag(self, data, len, attr);
	    dispose_attr(&attr);
	    break;
	case T_NONE: break;
	default: assert(! "Cannot happen");
	}
    }
}
#line 2150 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 2150 "SSGML.w"
static void get_parser_state(Widget self,String * text,Cardinal * nchars,Cardinal * nparsed)
#else
#line 2150 "SSGML.w"
static void get_parser_state(self,text,nchars,nparsed)Widget self;String * text;Cardinal * nchars;Cardinal * nparsed;
#endif
#line 2151 "SSGML.w"
{*text = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text; *nchars = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars; *nparsed = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed;}
#line 2156 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 2156 "SSGML.w"
static void set_parser_state(Widget self,String  text,Cardinal  nchars,Cardinal  nparsed)
#else
#line 2156 "SSGML.w"
static void set_parser_state(self,text,nchars,nparsed)Widget self;String  text;Cardinal  nchars;Cardinal  nparsed;
#endif
#line 2157 "SSGML.w"
{((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text = text; ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars = nchars; ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = nparsed;}
#line 2168 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 2168 "SSGML.w"
static int  alloc_extradata(Widget self,char * url,Bool  ismap)
#else
#line 2168 "SSGML.w"
static int  alloc_extradata(self,url,ismap)Widget self;char * url;Bool  ismap;
#endif
#line 2169 "SSGML.w"
{
    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata_allocated == ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata) {
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata_allocated += ED_INCR;
	renewarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata_allocated);
    }
    new(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata]);
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata]->url = XtNewString(url);
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata]->ismap = ismap;
    return ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata++;
}

static XtResource resources[] = {
#line 20 "SSGML.w"
{XtNstyle,XtCStyle,XtRString,sizeof(((XfwfSimpleSGMLRec*)NULL)->xfwfSimpleSGML.style),XtOffsetOf(XfwfSimpleSGMLRec,xfwfSimpleSGML.style),XtRImmediate,(XtPointer)NULL },
#line 26 "SSGML.w"
{XtNtitle,XtCTitle,XtRString,sizeof(((XfwfSimpleSGMLRec*)NULL)->xfwfSimpleSGML.title),XtOffsetOf(XfwfSimpleSGMLRec,xfwfSimpleSGML.title),XtRImmediate,(XtPointer)NULL },
};

XfwfSimpleSGMLClassRec xfwfSimpleSGMLClassRec = {
{ /* core_class part */
/* superclass   	*/  (WidgetClass) &xfwfFormattedTextClassRec,
/* class_name   	*/  "XfwfSimpleSGML",
/* widget_size  	*/  sizeof(XfwfSimpleSGMLRec),
/* class_initialize 	*/  class_initialize,
/* class_part_initialize*/  _resolve_inheritance,
/* class_inited 	*/  FALSE,
/* initialize   	*/  initialize,
/* initialize_hook 	*/  NULL,
/* realize      	*/  XtInheritRealize,
/* actions      	*/  NULL,
/* num_actions  	*/  0,
/* resources    	*/  resources,
/* num_resources 	*/  2,
/* xrm_class    	*/  NULLQUARK,
/* compres_motion 	*/  FALSE ,
/* compress_exposure 	*/  XtExposeCompressMultiple |XtExposeGraphicsExposeMerged ,
/* compress_enterleave 	*/  True ,
/* visible_interest 	*/  False ,
/* destroy      	*/  destroy,
/* resize       	*/  XtInheritResize,
/* expose       	*/  XtInheritExpose,
/* set_values   	*/  set_values,
/* set_values_hook 	*/  NULL,
/* set_values_almost 	*/  XtInheritSetValuesAlmost,
/* get_values+hook 	*/  NULL,
/* accept_focus 	*/  XtInheritAcceptFocus,
/* version      	*/  XtVersion,
/* callback_private 	*/  NULL,
/* tm_table      	*/  defaultTranslations,
/* query_geometry 	*/  XtInheritQueryGeometry,
/* display_acceleator 	*/  XtInheritDisplayAccelerator,
/* extension    	*/  NULL 
},
{ /* composite_class part */
XtInheritGeometryManager,
XtInheritChangeManaged,
XtInheritInsertChild,
XtInheritDeleteChild,
NULL
},
{ /* constraint_class part */
/* constraint_resources     */  NULL,
/* num_constraint_resources */  0,
/* constraint_size          */  sizeof(XfwfSimpleSGMLConstraintRec),
/* constraint_initialize    */  NULL,
/* constraint_destroy       */  NULL,
/* constraint_set_values    */  NULL,
/* constraint_extension     */  NULL 
},
{ /* XmManager class part */
#define manager_extension extension
/* translations                 */  XtInheritTranslations ,
/* syn_resources                */  NULL ,
/* num_syn_resources            */  0 ,
/* syn_constraint_resources     */  NULL ,
/* num_syn_constraint_resources */  0 ,
/* parent_process               */  XmInheritParentProcess,
/* manager_extension            */  NULL ,
},
{ /* XfwfFormattedText_class part */
XtInherit_add_word,
XtInherit_add_hspace,
XtInherit_add_vspace,
XtInherit_add_inline,
XtInherit_add_parshape,
XtInherit_add_hrule,
XtInherit_add_eod,
XtInherit_pass_click,
XtInherit_reformat_scrollbar,
XtInherit_get_em_of_textstyle,
XtInherit_get_space_of_textstyle,
XtInherit_get_lineheight_of_textstyle,
XtInherit_get_word_extent,
},
{ /* XfwfSimpleSGML_class part */
pop_style,
make_child_from_source,
scan_num,
push_style,
get_entity,
process_entity,
add_endtag,
add_starttag,
add_text,
get_attrib,
},
};
WidgetClass xfwfSimpleSGMLWidgetClass = (WidgetClass) &xfwfSimpleSGMLClassRec;
static void _resolve_inheritance(class)
WidgetClass class;
{
  XfwfSimpleSGMLWidgetClass c = (XfwfSimpleSGMLWidgetClass) class;
  XfwfSimpleSGMLWidgetClass super;
  static CompositeClassExtensionRec extension_rec = {
    NULL, NULLQUARK, XtCompositeExtensionVersion,
    sizeof(CompositeClassExtensionRec), True};
  CompositeClassExtensionRec *ext;
  ext = (XtPointer)XtMalloc(sizeof(*ext));
  *ext = extension_rec;
  ext->next_extension = c->composite_class.extension;
  c->composite_class.extension = ext;
  if (class == xfwfSimpleSGMLWidgetClass) return;
  super = (XfwfSimpleSGMLWidgetClass)class->core_class.superclass;
  if (c->xfwfSimpleSGML_class.pop_style == XtInherit_pop_style)
    c->xfwfSimpleSGML_class.pop_style = super->xfwfSimpleSGML_class.pop_style;
  if (c->xfwfSimpleSGML_class.make_child_from_source == XtInherit_make_child_from_source)
    c->xfwfSimpleSGML_class.make_child_from_source = super->xfwfSimpleSGML_class.make_child_from_source;
  if (c->xfwfSimpleSGML_class.scan_num == XtInherit_scan_num)
    c->xfwfSimpleSGML_class.scan_num = super->xfwfSimpleSGML_class.scan_num;
  if (c->xfwfSimpleSGML_class.push_style == XtInherit_push_style)
    c->xfwfSimpleSGML_class.push_style = super->xfwfSimpleSGML_class.push_style;
  if (c->xfwfSimpleSGML_class.get_entity == XtInherit_get_entity)
    c->xfwfSimpleSGML_class.get_entity = super->xfwfSimpleSGML_class.get_entity;
  if (c->xfwfSimpleSGML_class.process_entity == XtInherit_process_entity)
    c->xfwfSimpleSGML_class.process_entity = super->xfwfSimpleSGML_class.process_entity;
  if (c->xfwfSimpleSGML_class.add_endtag == XtInherit_add_endtag)
    c->xfwfSimpleSGML_class.add_endtag = super->xfwfSimpleSGML_class.add_endtag;
  if (c->xfwfSimpleSGML_class.add_starttag == XtInherit_add_starttag)
    c->xfwfSimpleSGML_class.add_starttag = super->xfwfSimpleSGML_class.add_starttag;
  if (c->xfwfSimpleSGML_class.add_text == XtInherit_add_text)
    c->xfwfSimpleSGML_class.add_text = super->xfwfSimpleSGML_class.add_text;
  if (c->xfwfSimpleSGML_class.get_attrib == XtInherit_get_attrib)
    c->xfwfSimpleSGML_class.get_attrib = super->xfwfSimpleSGML_class.get_attrib;
}
#line 189 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 189 "SSGML.w"
static void class_initialize(void)
#else
#line 189 "SSGML.w"
static void class_initialize()
#endif
#line 190 "SSGML.w"
{
    XtAddConverter(XtRString, XtRJustify, XmuCvtStringToJustify, NULL, 0);
    init_style_quarks();
    init_entity_quarks();
}
#line 196 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 196 "SSGML.w"
static void initialize(Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 196 "SSGML.w"
static void initialize(request,self,args,num_args)Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 197 "SSGML.w"
{
    newarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata, 1);			/* Allocate 1 entry */
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[0] = NULL;			/* Entry 0 is always NULL */
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata = 1;				/* One entry used so far */
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata_allocated = 1;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title = NULL;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text = 0;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars = 0;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nparsed = 0;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer = NULL;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb = XrmGetStringDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.style ? ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.style : "");
    init_stystack(self);
}
#line 214 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 214 "SSGML.w"
static Boolean  set_values(Widget  old,Widget  request,Widget self,ArgList  args,Cardinal * num_args)
#else
#line 214 "SSGML.w"
static Boolean  set_values(old,request,self,args,num_args)Widget  old;Widget  request;Widget self;ArgList  args;Cardinal * num_args;
#endif
#line 215 "SSGML.w"
{
    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.style != ((XfwfSimpleSGMLWidget)old)->xfwfSimpleSGML.style) {
	XrmDestroyDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb = XrmGetStringDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.style ? ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.style : "");
    }
    return FALSE;
}
#line 223 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 223 "SSGML.w"
static void destroy(Widget self)
#else
#line 223 "SSGML.w"
static void destroy(self)Widget self;
#endif
#line 224 "SSGML.w"
{
    FormatInfo sty;
    int i;

    XtFree(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.title);
    XrmDestroyDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
    while (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack) {
	sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack = sty->next;
	dispose(sty);
    }
    XrmDestroyDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
    for (i = 1; i < ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nrextradata; i++) {
	XtFree(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[i]->url);
	XtFree((String) ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[i]);
    }
    XtFree((String) ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata);
}
#line 247 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 247 "SSGML.w"
static void pop_style(Widget self)
#else
#line 247 "SSGML.w"
static void pop_style(self)Widget self;
#endif
#line 248 "SSGML.w"
{
    Cardinal save_nchars, save_nparsed;
    String save_text;
    FormatInfo sty;

    assert(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->next != NULL);
#if 0
#ifndef NDEBUG
    {
	XrmQuark nest[TAGLVL];
	int h;
	tag_nesting_to_quarklist(self, nest);
	fprintf(stderr, "<<< ");
	for (h = 0; nest[h]; h++)
	    fprintf(stderr, ".%s", XrmQuarkToString(nest[h]));
	fprintf(stderr, "\n");
    }
#endif
#endif
    sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;

    if (! sty->next->hide) {
	if (sty->insafter[0]) {			/* Insert text */
	    /*
	     *  Warning! This may cause infinite recursion, e.g:
	     *  *WBR.insertafter: <WBR>
	     */
	    get_parser_state(self, &save_text, &save_nchars, &save_nparsed);
	    set_parser_state(self, sty->insafter, strlen(sty->insafter), 0);
	    parse_text(self, True);
	    set_parser_state(self, save_text, save_nchars, save_nparsed);
	}
	if (sty->hrule_after) {			/* Insert rule */
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_vspace(self, sty->hrulebreak);
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hrule(self);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	}
	if (sty->break_after) {			/* Insert vspace */
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_vspace(self, sty->postbreak);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	}
	if (sty->leftmargin != sty->next->leftmargin
	    || sty->rightmargin != sty->next->rightmargin
	    || sty->width != sty->next->width
	    || sty->parmode != sty->next->parmode) {
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_parshape(self, sty->next->leftmargin, sty->next->rightmargin,
			  sty->next->width, sty->next->parmode, sty->leading);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	}
	if (sty->suppress_indent) {
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.suppress_indent = TRUE;
	}
    }
    if (sty->stylesheet != NULL) {
	/* At the end of a stylesheet specification */
	XrmDatabase db = XrmGetStringDatabase(sty->stylesheet);
	switch (sty->stylesheettype) {
	case StyleMerge:
	    XrmCombineDatabase(db, &((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb, FALSE);
	    XrmDestroyDatabase(db);
	    break;
	case StyleOverride:
	    XrmMergeDatabases(db, &((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
	    break;
	case StyleReplace:
	    XrmDestroyDatabase(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
	    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb = NULL;
	    XrmMergeDatabases(db, &((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb);
	    break;
	case StyleNo:
	default:
	    assert(! "Cannot happen");
	}
	XtFree(sty->stylesheet);
    }
    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer != NULL && ! sty->next->save_content) {
	/* At the end of a save-content area */
	dispose(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.contentbuffer);
    }

    /* Now pop the style record */
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack = sty->next;

    /* Free the occupied memory */
    dispose(sty);
}
#line 346 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 346 "SSGML.w"
static void make_child_from_source(Widget self,Widget  w,const  String  src)
#else
#line 346 "SSGML.w"
static void make_child_from_source(self,w,src)Widget self;Widget  w;const  String  src;
#endif
#line 347 "SSGML.w"
{
    /* Left to subclasses */
}
#define MAXSTYLEATTR 100 


#line 367 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 367 "SSGML.w"
static Bool  scan_num(char * s,char * cp,int * np)
#else
#line 367 "SSGML.w"
static Bool  scan_num(s,cp,np)char * s;char * cp;int * np;
#endif
#line 368 "SSGML.w"
{
    if (sscanf(s, "%1s%u", cp, np) == 2 && (*cp == '-' || *cp == '+'))
	return TRUE;
    else {
	*cp = '\0';
	return sscanf(s, "%u", np) == 1;
    }
}
#line 377 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 377 "SSGML.w"
static void push_style(Widget self,XrmQuark  tag,Attrib  attr)
#else
#line 377 "SSGML.w"
static void push_style(self,tag,attr)Widget self;XrmQuark  tag;Attrib  attr;
#endif
#line 378 "SSGML.w"
{
    XrmHashTable list[MAXSTYLEATTR], idlist[MAXSTYLEATTR];
    XrmQuark nest[TAGLVL], id[2], repr;
    char s[LITLEN+1], buf[LITLEN+2];
    XrmValue v1, val;
    FormatInfo sty;
    Bool ok, has_id;
    float f;
    int h, n;
    char prefix;

    /* Push new style record */
    new(sty);
    sty->next = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack;
    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack = sty;
    sty->tag = tag;
    sty->children = 0;				/* Count sub-elements */
    sty->next->children++;			/* For counting labels */

    /* Get subset of style resource for current element */
    tag_nesting_to_quarklist(self, nest);
#if 0
#ifndef NDEBUG
    fprintf(stderr, ">>> ");
    for (h = 0; nest[h]; h++)
	fprintf(stderr, ".%s", XrmQuarkToString(nest[h]));
    fprintf(stderr, "\n");
#endif
#endif
    ok = XrmQGetSearchList(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb, nest, nest, list, MAXSTYLEATTR);

    /* If the element has an ID, construct another resource list */
    has_id = ok && get_property(self, list, attr, QID, buf + 1);
    if (has_id) {
	buf[0] = '@';			/* Insert '@' in front */
	id[0] = XrmStringToQuark(buf);
	id[1] = 0;
	has_id = XrmQGetSearchList(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.styledb, id, id, idlist, MAXSTYLEATTR);
    }
    
    /* "*BODY.tile: ..." tile the window with a pixmap */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTILE, buf))
	    || get_property(self, list, attr, QTILE, buf))) {
	Pixmap tile;
	int status = XpmCreatePixmapFromBuffer
	    (XtDisplay(self), RootWindowOfScreen(XtScreen(self)), buf,
	     &tile, NULL, NULL);
	if (status == XpmColorError || status == XpmSuccess) {
	    XtVaSetValues(self, XmNbackgroundPixmap, tile, NULL);
	    XFreePixmap(XtDisplay(self), tile);
	}
    }

    /* "*A.target: !NAME" attribute that contains hyper target name */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTARGET, buf))
	    || get_property(self, list, attr, QTARGET, buf))) {
	/*
	 * s is an ID, for use as hyper target... not implemented
	 */
    }

    sty->textstyle = sty->next->textstyle;

    /* "*H1.size: +3" font size in <H1> increased by 3 */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QSIZE, buf))
	    || get_property(self, list, attr, QSIZE, buf))
	&& scan_num(buf, &prefix, &n)) {
	int h;
	h = (sty->textstyle & FtSIZEMASK) >> FtSIZESHIFT;
	if (prefix == '+') h = max(0, min(6, h + n));
	else if (prefix == '-') h = max(0, min(6, h - n));
	else h = max(0, min(6, n));
	sty->textstyle &= ~FtSIZEMASK;
	sty->textstyle |= h << FtSIZESHIFT;
    }

    /* "*H1.family: alt" alternative font family in <H1> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QFAMILY, buf))
	    || get_property(self, list, attr, QFAMILY, buf))) {
	int h;
	if (XmuCompareISOLatin1(buf, "normal") == 0) h = FtFAMILY1;
	else if (XmuCompareISOLatin1(buf, "alt") == 0) h = FtFAMILY2;
	else if (XmuCompareISOLatin1(buf, "tt") == 0) h = FtFAMILY3;
	else if (XmuCompareISOLatin1(buf, "sym") == 0) h = FtFAMILY4;
	else h = sty->next->textstyle &= FtFAMILYMASK;
	sty->textstyle &= ~FtFAMILYMASK;
	sty->textstyle |= h;
    }

    /* familyname not supported */

    /* "*EM.emphasis: 1" use simple emphasis in <EM> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QEMPHASIS, buf))
	    || get_property(self, list, attr, QEMPHASIS, buf))
	&& sscanf(buf, "%u", &n) == 1) {
	sty->textstyle &= ~(FtBOLD | FtITALIC);
	if (n >= 3) sty->textstyle |= FtBOLD | FtITALIC;
	else if (n == 2) sty->textstyle |= FtBOLD;
	else if (n == 1) sty->textstyle |= FtITALIC;
    }

    /* "*I.slant: true" use italic font for <I> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QSLANT, buf))
	    || get_property(self, list, attr, QSLANT, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	if (*((Bool *) v1.addr)) sty->textstyle |= FtITALIC;
	else sty->textstyle &= ~FtITALIC;
    }

    /* "*B.bold: true" use bold font for <B> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QBOLD, buf))
	    || get_property(self, list, attr, QBOLD, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	if (*((Bool *) v1.addr)) sty->textstyle |= FtBOLD;
	else sty->textstyle &= ~FtBOLD;
    }

    /* "*U.underscore: 1" underline <U> with a single line */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QUSCORE, buf))
	    || get_property(self, list, attr, QUSCORE, buf))
	&& sscanf(buf, "%u", &n) == 1) {
	if (n >= 3) sty->textstyle |= FtUNDERSCORE2 | FtUNDERSCORE;
	else if (n == 2) sty->textstyle |= FtUNDERSCORE2;
	else if (n == 1) sty->textstyle |= FtUNDERSCORE;
	else sty->textstyle &= ~(FtUNDERSCORE2 | FtUNDERSCORE);
    }

    /* "*S.strikeout: true" put a line through <S> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QSTRIKE, buf))
	    || get_property(self, list, attr, QSTRIKE, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	if (*((Bool *) v1.addr)) sty->textstyle |= FtSTRIKE;
	else sty->textstyle &= ~FtSTRIKE;
    }

    /* "*SUB*SUB.raise: -2" lower text in <SUP>..<SUB> 2 level2 */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QRAISE, buf))
	    || get_property(self, list, attr, QRAISE, buf))
	&& sscanf(buf, "%i", &n) == 1) {
	sty->textstyle &= ~FtSUPERMASK;
	sty->textstyle &= ~FtSUBMASK;
	if (n < -3) sty->textstyle |= 3 << FtSUBSHIFT;
	else if (n < 0) sty->textstyle |= (-n) << FtSUBSHIFT;
	else if (n == 0) ;
	else if (n <= 3) sty->textstyle |= n << FtSUPERSHIFT;
	else sty->textstyle |= 3 << FtSUPERSHIFT;
    }

    /* "*UL.postbreak: 1.0" skip one line after a <UL> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QPOSTBREAK, buf))
	    || get_property(self, list, attr, QPOSTBREAK, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->break_after = TRUE;
	sty->postbreak = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline);
    } else {
	sty->break_after = FALSE;
    }

    /* "*UL.ruleafter: 0.5" a hor. rule after <UL>, separated by 0.5 line */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QRULEAFTER, buf))
	    || get_property(self, list, attr, QRULEAFTER, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->hrule_after = TRUE;
	sty->hrulebreak = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline);
    } else {
	sty->hrule_after = FALSE;
    }

    /* "*IMG.ismap: true" a hyperlink should be followed by x,y */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QISMAP, buf))
	    || get_property(self, list, attr, QISMAP, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->ismap = *((Bool *) v1.addr);
    } else {
	sty->ismap = sty->next->ismap;
    }

    /* "*A.anchor: !HREF" HREF-attrib in <A> contains hyperlink */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QANCHOR, buf))
	    || get_property(self, list, attr, QANCHOR, buf))) {
	sty->data = alloc_extradata(self, buf, sty->ismap);
    } else {
	sty->data = sty->next->data;
    }

    /* Check and update "ismap" if it changed */
    if (sty->data && ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]->ismap != sty->ismap) {
	sty->data = alloc_extradata(self, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]->url, sty->ismap);
    }

    /* "*A.textcolor: blue" foreground is blue inside <A> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTEXTCOLOR, buf))
	    || get_property(self, list, attr, QTEXTCOLOR, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRPixel, &v1)) {
	sty->fg = *((Pixel *) v1.addr);
    } else {
	sty->fg = sty->next->fg;
    }

    /* "*A.textbackground: yellow" background is yellow inside <A> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    sty->bg = sty->next->bg;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTEXTBG, buf))
	    || get_property(self, list, attr, QTEXTBG, buf))) {
	if (XmuCompareISOLatin1(buf, "transparent") == 0)
	    sty->bg = TRANSPARENT;
	else if (XtConvertAndStore(self, XtRString, &val, XtRPixel, &v1))
	    sty->bg = *((Pixel *) v1.addr);
    }

    /* "*TITLE.title: True" contents of <TITLE> constitute the title */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTITLE, buf))
	    || get_property(self, list, attr, QTITLE, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->title = *((Bool *) v1.addr);
    } else {
	sty->title = sty->next->title;
    }

    /* "*STYLE.stylesheet: merge" contents of <STYLE> are a stylesheet */
    sty->stylesheet = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QSTYLESHEET, buf))
	    || get_property(self, list, attr, QSTYLESHEET, buf))) {
	if (XmuCompareISOLatin1(buf, "merge") == 0)
	    sty->stylesheettype = StyleMerge;
	else if (XmuCompareISOLatin1(buf, "replace") == 0)
	    sty->stylesheettype = StyleReplace;
	else if (XmuCompareISOLatin1(buf, "override") == 0)
	    sty->stylesheettype = StyleOverride;
	else
	    sty->stylesheettype = StyleNo;
    } else {
	sty->stylesheettype = sty->next->stylesheettype;
    }

    /* "*PRE.obeyspaces: True" every space counts in <PRE> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QOBEYSP, buf))
	    || get_property(self, list, attr, QOBEYSP, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->verbatim = *((Bool *) v1.addr);
    } else {
	sty->verbatim = sty->next->verbatim;
    }

    /* "*NOBR.nowrap: True" don't break lines inside <NOBR> */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QNOWRAP, buf))
	    || get_property(self, list, attr, QNOWRAP, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->nowrap = *((Bool *) v1.addr);
    } else {
	sty->nowrap = sty->next->nowrap;
    }

    /* "*HEAD.hide: True" contents of <HEAD> are not displayed */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QHIDE, buf))
	    || get_property(self, list, attr, QHIDE, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->hide = *((Bool *) v1.addr);
    } else {
	sty->hide = sty->next->hide;
    }

    /* "*P.parindent: 2.0" indent first line of paragraph 2 ems */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QPARINDENT, buf))
	    || get_property(self, list, attr, QPARINDENT, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->parindent = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em);
    } else {
	sty->parindent = sty->next->parindent;
    }

    /* "*H1.noindent: true" don't indent 1st para *after* H1 */
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QNOINDENT, buf))
	    || get_property(self, list, attr, QNOINDENT, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->suppress_indent = *((Bool *) v1.addr);
    } else {
	sty->suppress_indent = sty->next->suppress_indent;
    }

    /*
     * Paragraph modes
     */
    sty->parmode = sty->next->parmode;

    /* "*H2.justify: left" left-align text in <H1> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QJUSTIFY, buf))
	    || get_property(self, list, attr, QJUSTIFY, buf))) {
	if (XmuCompareISOLatin1(buf, "left") == 0)
	    sty->parmode = (sty->parmode & ~FtJUSTIFYMASK) | FtJUSTIFYLEFT;
	else if (XmuCompareISOLatin1(buf, "right") == 0)
	    sty->parmode = (sty->parmode & ~FtJUSTIFYMASK) | FtJUSTIFYRIGHT;
	else if (XmuCompareISOLatin1(buf, "center") == 0)
	    sty->parmode = (sty->parmode & ~FtJUSTIFYMASK) | FtJUSTIFYCENTER;
	else if (XmuCompareISOLatin1(buf, "full") == 0)
	    sty->parmode = (sty->parmode & ~FtJUSTIFYMASK) | FtJUSTIFYBOTH;
	/* else unrecognized keyword */
    }

    /* "*FIG.track: !ALIGN" attribute that contains position */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTRACK, buf))
	    || get_property(self, list, attr, QTRACK, buf))) {
	if (XmuCompareISOLatin1(buf, "left") == 0)
	    sty->parmode = (sty->parmode & ~FtPOSITIONMASK) | FtLEFTFLOAT;
	else if (XmuCompareISOLatin1(buf, "right") == 0)
	    sty->parmode = (sty->parmode & ~FtPOSITIONMASK) | FtRIGHTFLOAT;
	else if (XmuCompareISOLatin1(buf, "right") == 0)
	    sty->parmode = (sty->parmode & ~FtPOSITIONMASK) | FtNORMALPARA;
	/* else unrecognized keyword */
    }

    /* "*LI.leftindent: 3.0" indent text in <LI> by 3em */
    sty->leftmargin = sty->next->leftmargin;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QLINDENT, buf))
	    || get_property(self, list, attr, QLINDENT, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->leftmargin += round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em);
    }

    /* "*QUOTE.rightindent: 3.0" right-indent text in <QUOTE> by 3em */
    sty->rightmargin = sty->next->rightmargin;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QRINDENT, buf))
	    || get_property(self, list, attr, QRINDENT, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->rightmargin += round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em);
    }

    /* "*NOTE.textwidth: 30.0" NOTE paragraph is 30 em wide */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QTEXTWIDTH, buf))
	    || get_property(self, list, attr, QTEXTWIDTH, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->width = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em);
    } else {
	sty->width = sty->next->width;
    }

    /* "*QUOTE.leading: 2.0" double spacing <QUOTE> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QLEADING, buf))
	    || get_property(self, list, attr, QLEADING, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->leading = f;
    } else {
	sty->leading = sty->next->leading;
    }

    /* "*BR.flush: !CLEAR" move to below floats if CLEAR attr. says so */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QFLUSH, buf))
	    || get_property(self, list, attr, QFLUSH, buf))) {
	if (XmuCompareISOLatin1(buf, "left") == 0)
	    sty->flush = FtCLEARLEFT;
	else if (XmuCompareISOLatin1(buf, "right") == 0)
	    sty->flush = FtCLEARRIGHT;
	else if (XmuCompareISOLatin1(buf, "full") == 0)
	    sty->flush = FtCLEARLEFT | FtCLEARRIGHT;
	else
	    sty->flush = FtNOCLEAR;
    } else {
	sty->flush = FtNOCLEAR;			/* Not inherited */
    }

    /*
     * Execute parshape, if anything changed.
     * We could check sty->hide, instead of sty->next->hide,
     * but then we would need to add the parshape after all when
     * there is an `inline'
     */
    if (! sty->next->hide
	&& (sty->leftmargin != sty->next->leftmargin
	    || sty->rightmargin != sty->next->rightmargin
	    || sty->width != sty->next->width
	    || sty->parmode != sty->next->parmode
	    || sty->flush != FtNOCLEAR
	    || sty->leading != sty->next->leading)) {
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_parshape(self, sty->leftmargin, sty->rightmargin, sty->width,
		      sty->parmode | sty->flush, sty->leading);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
    }

    /* "*IMG.vmargin: 0.5" half a line above and below the object */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QVMARGIN, buf))
	    || get_property(self, list, attr, QVMARGIN, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->inlinevmargin = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline);
    } else {
	sty->inlinevmargin = sty->next->inlinevmargin;
    }

    /* "*IMG.hmargin: 0.5" half an em left and right of the object */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QHMARGIN, buf))
	    || get_property(self, list, attr, QHMARGIN, buf))
	&& sscanf(buf, "%f", &f) == 1) {
	sty->inlinehmargin = round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_em);
    } else {
	sty->inlinehmargin = sty->next->inlinehmargin;
    }

    /* "*IMG.inline: !SRC" <IMG> has an image in attribute "SRC" */
    if (ok && ! sty->next->hide
	&& ((has_id && get_property(self, idlist, attr, QINLINE, buf))
	    || get_property(self, list, attr, QINLINE, buf))) {
	Widget w;
	char buf1[LITLEN+2];
	int ht, wd, dp = 0, align = FtALIGNTOP;

	if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->data)
	    w = XtVaCreateManagedWidget
		("inline", xmManagerWidgetClass, self, 
		 XtNborderWidth, 2, XtNborderColor, sty->fg, NULL);
	else
	    w = XtVaCreateManagedWidget
		("inline", xmManagerWidgetClass, self,
		 XtNborderWidth, 0, NULL);

	/* "*IMG.valign: !ALIGN" <IMG> has a vert. alignment attrib. */
	if (ok
	    && ((has_id && get_property(self, idlist, attr, QVALIGN, buf1))
		|| get_property(self, list, attr, QVALIGN, buf1))) {
	    if (XmuCompareISOLatin1(buf1, "bottom") == 0)
		align = FtALIGNBOTTOM;
	    else if (XmuCompareISOLatin1(buf1, "middle") == 0)
		align = FtALIGNMIDDLE;
	}

	/* "*IMG.depth: !DEPTH" <IMG> has a depth attrib. */
	if (ok
	    && ((has_id && get_property(self, idlist, attr, QDEPTH, buf1))
		|| get_property(self, list, attr, QDEPTH, buf1))
	    && sscanf(buf1, "%i", &n) == 1) {
	    align = FtALIGNDEPTH;
	    dp = n;
	}

	/* "*IMG.width: 20" <IMG> has fixed width */
	if (ok
	    && ((has_id && get_property(self, idlist, attr, QWIDTH, buf1))
		|| get_property(self, list, attr, QWIDTH, buf1))
	    && sscanf(buf1, "%i", &n) == 1) {
	    align |= FtALIGNFIXEDWIDTH;
	    wd = n;
	}

	/* "*IMG.height: 20" <IMG> has fixed height */
	if (ok
	    && ((has_id && get_property(self, idlist, attr, QHEIGHT, buf1))
		|| get_property(self, list, attr, QHEIGHT, buf1))
	    && sscanf(buf1, "%i", &n) == 1) {
	    align |= FtALIGNFIXEDHEIGHT;
	    ht = n - dp;
	}

	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_inline(self, w, sty->textstyle | align, wd, ht, dp,
		    sty->inlinehmargin, sty->inlinevmargin,
		    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = FALSE;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = FALSE;
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.make_child_from_source(self, w, buf);
    }

    /* "*OL.prebreak: 0.5" skip half a line before an <OL> */
    if (ok && ! sty->next->hide
	&& ((has_id && get_property(self, idlist, attr, QPREBREAK, buf))
	    || get_property(self, list, attr, QPREBREAK, buf))
	&& sscanf(buf, "%f", &f) == 1) {
        /* `prebreak' is excecuted immediately */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_vspace(self, round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline));
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
    }

    /* "*OL.rulebefore: 0.5" hor. rule before <OL>, followed by 0.5 line */
    if (ok && ! sty->next->hide
	&& ((has_id && get_property(self, idlist, attr, QRULEBEFORE, buf))
	    || get_property(self, list, attr, QRULEBEFORE, buf))
	&& sscanf(buf, "%f", &f) == 1) {
        /* `rulebefore' is excecuted immediately */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hrule(self);
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_vspace(self, round(f * ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.default_baseline));
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = TRUE;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
    }

    /* "*UL.LI.label: bullet" put a label in front of <LI> */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QLABEL, buf))
	    || get_property(self, list, attr, QLABEL, buf))) {
	char t[10];
	Cardinal len = 1; int w, h, d, raise, sp;
	TextStyle style = sty->textstyle | FtBOLD;
	if (strcmp(buf, "a") == 0)
	    t[0] = 'a' - 1 + sty->next->children;
	else if (strcmp(buf, "A") == 0)
	    t[0] = 'A' - 1 + sty->next->children;
	else if (strcmp(buf, "1") == 0)
	    len = sprintf(t, "%i", sty->next->children);
	else {
	    t[0] = '\267';			/* Bullet */
	    style = (style & ~(FtFAMILYMASK|FtSTYLEMASK)) | FtFAMILY5;
	}
	/* Others not implemented yet... */
	sp = ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.get_space_of_textstyle(self, style);
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.get_word_extent(self, t, len, style, &h, &d, &w, &raise);
	w = 1000 * w/sp + 2000;			/* Label + 2 spaces */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, -w, FALSE, FALSE, sty->fg, sty->bg, style,
		    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_word(self, t, len, sty->fg, sty->bg, style | FtHIDEWIDTH,
		  ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, w, FALSE, FALSE, sty->fg, sty->bg, style,
		    ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[sty->data]);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = FALSE;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.previous_is_blank = TRUE;
    }

    /* "*WBR.insertbefore: &sbsp;" insert text at start of <WBR> */
    if (ok
	&& (( has_id && get_property(self, idlist, attr, QINSBEFORE, buf))
	    || get_property(self, list, attr, QINSBEFORE, buf))) {
	String save_text;
	Cardinal save_nchars, save_nparsed;
	/*
	 *  Warning! This may cause infinite recursion, e.g:
	 *  *WBR.insertbefore: <WBR>
	 */
	get_parser_state(self, &save_text, &save_nchars, &save_nparsed);
	set_parser_state(self, buf, strlen(buf), 0);
	parse_text(self, True);
	set_parser_state(self, save_text, save_nchars, save_nparsed);
    }

    /* "*Q.insertafter: '" insert text after </Q> */
    if (ok
	&& (( has_id && get_property(self, idlist, attr, QINSAFTER, buf))
	    || get_property(self, list, attr, QINSAFTER, buf))) {
	strcpy(sty->insafter, buf);
    } else {
	sty->insafter[0] = '\0';		/* Not inherited */
    }

    /* "*OPTION.savecontent: TRUE" store content in buffer */
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QSAVECONT, buf))
	    || get_property(self, list, attr, QSAVECONT, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	sty->save_content = *((Bool *) v1.addr);
    } else {
	sty->save_content = sty->next->save_content;
    }

    /* "*BR.empty: True" <BR> is an empty tag */
    assert(sizeof(buf) > LITLEN);
    val.size = LITLEN + 1; val.addr = buf; v1.addr = NULL;
    if (ok
	&& ((has_id && get_property(self, idlist, attr, QEMPTY, buf))
	    || get_property(self, list, attr, QEMPTY, buf))
	&& XtConvertAndStore(self, XtRString, &val, XtRBool, &v1)) {
	if (*((Bool *) v1.addr)) ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.pop_style(self);
    }
}
#line 987 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 987 "SSGML.w"
static Bool  get_entity(Widget self,const  String  name,Cardinal  namelen,char  val[],Cardinal  maxlen,int * charset)
#else
#line 987 "SSGML.w"
static Bool  get_entity(self,name,namelen,val,maxlen,charset)Widget self;const  String  name;Cardinal  namelen;char  val[];Cardinal  maxlen;int * charset;
#endif
#line 988 "SSGML.w"
{
    char s[NAMELEN+1];
    XrmQuark q;
    int i;

    s[0] = '\0';
    strncat(s, name, min(NAMELEN, namelen));
    q = XrmStringToQuark(s);
    for (i = 0; i < XtNumber(entities); i++)
	if (entities[i].q == q) {
	    val[0] = '\0';
	    strncat(val, entities[i].value, maxlen);
	    *charset = entities[i].charset;
	    return TRUE;
	}
    /* Not found, return name itself and FALSE */
    val[0] = '\0';
    strncat(val, "&", maxlen);
    strncat(val, name, min(namelen, maxlen - 1));
    strncat(val, ";", maxlen - namelen - 1);
    *charset = ISO8859_1;
    return FALSE;
}
#line 1018 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1018 "SSGML.w"
static void process_entity(Widget self,const  String  data,Cardinal  len)
#else
#line 1018 "SSGML.w"
static void process_entity(self,data,len)Widget self;const  String  data;Cardinal  len;
#endif
#line 1019 "SSGML.w"
{
    char s[LITLEN+1];
    int charset, style;
    int n;

    if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->tag != PCDATA_TAG)		/* Start #PCDATA */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_starttag(self, "#PCDATA", 7, NULL);

    if (data[0] != '#') {
	(void) ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.get_entity(self, data, len, s, sizeof(s), &charset);
    } else {					/* Numerical entity */
	s[0] = '\0'; strncat(s, data + 1, len - 1);
	if (sscanf(strncat(s, data + 1, len - 1), "%d", &n) != 1) {
	    strcpy(s, "&");			/* Number too large? */
	    strncat(s, data, min(sizeof(s) - 3, len));
	    strcat(s, ";");
	} else {
	    s[0] = (n ? n : 0xff) & 0xff;	/* Number -> char */
	    s[1] = '\0';
	}
	charset = ISO8859_1;
    }
    style = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->textstyle;
    if (charset == SYSTEM_DATA) {
	if (strcmp(s, "sbsp") == 0) {		/* Soft break space */
	    if (! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->title && ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->stylesheettype == StyleNo
		&& ! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->hide)
		((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, 0, FALSE, TRUE, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->fg, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->bg,
			    style, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->data]);
	} else if (strcmp(s, "nbsp") == 0) {	/* No break (required) space */
	    if (! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->title && ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->stylesheettype == StyleNo
		&& ! ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->hide) {
		((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.add_hspace(self, 1000, TRUE, FALSE, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->fg, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->bg,
			    style, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->data]);
		CHK_SAVE_CONTENT(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack, " ", 1);
	    } else
		add_spaces(self, " ", 1);
	} /* else: not handled yet */
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.start_of_par = FALSE;
    } else {
	if (charset == WWW_ICONS)
	    style = (style & ~FtFAMILYMASK) | FtFAMILY4;
	else if (charset == SYMBOLS)
	    style = (style & ~FtFAMILYMASK) | FtFAMILY5;
	add_word(self, s, strlen(s), ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->fg, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->bg, style,
		 ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->parindent, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.extradata[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->data]);
    }
}
#line 1073 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1073 "SSGML.w"
static void add_endtag(Widget self,const  String  name,Cardinal  namelen)
#else
#line 1073 "SSGML.w"
static void add_endtag(self,name,namelen)Widget self;const  String  name;Cardinal  namelen;
#endif
#line 1074 "SSGML.w"
{
    char t[NAMELEN+1] = "";
    XrmQuark tag;
    FormatInfo sty;

    if (namelen == 0) {				/* Null endtag */
	if (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->next) ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.pop_style(self);	/* Just pop top element */
	return;
    }
    tag = XrmStringToQuark(upper(strncat(t, name, min(NAMELEN, namelen))));
    /* Check if the named tag is indeed open */
    for (sty = ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack; sty->next; sty = sty->next)
	if (sty->tag == tag) {
	    /* It is open, pop elements up to and including tag */
	    while (((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.stystack->tag != tag) ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.pop_style(self);
	    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.pop_style(self);
	    break;
	}
}
#line 1100 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1100 "SSGML.w"
static void add_starttag(Widget self,const  String  name,Cardinal  namelen,Attrib  attr)
#else
#line 1100 "SSGML.w"
static void add_starttag(self,name,namelen,attr)Widget self;const  String  name;Cardinal  namelen;Attrib  attr;
#endif
#line 1101 "SSGML.w"
{
    char t[NAMELEN+1] = "";

    upper(strncat(t, name, min(NAMELEN, namelen)));
    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.push_style(self, XrmStringToQuark(t), attr);
}
#line 1108 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1108 "SSGML.w"
static void add_text(Widget self,const  char * text,Cardinal  nchars)
#else
#line 1108 "SSGML.w"
static void add_text(self,text,nchars)Widget self;const  char * text;Cardinal  nchars;
#endif
#line 1109 "SSGML.w"
{
    if (nchars != 0) {				/* Add to buffered text */
	renewarray(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text, ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars + nchars + 1);
	memcpy(((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text + ((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars, text, nchars);
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars += nchars;
	((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.text[((XfwfSimpleSGMLWidget)self)->xfwfSimpleSGML.nchars] = '\0';
    }
    parse_text(self, (nchars == 0));		/* Parse tokens */
    if (nchars == 0)
	add_eod(self);				/* End of input */
    else {
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->core_class.expose(self, NULL, NULL);			/* Make sure output appears */
	((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfFormattedText_class.reformat_scrollbar(self);
    }
}
#line 1130 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 1130 "SSGML.w"
static Bool  get_attrib(Widget self,Attrib  attr,const  String  name,char  value[],Cardinal  maxlen)
#else
#line 1130 "SSGML.w"
static Bool  get_attrib(self,attr,name,value,maxlen)Widget self;Attrib  attr;const  String  name;char  value[];Cardinal  maxlen;
#endif
#line 1131 "SSGML.w"
{
    int i, j, k, dum;
    char s[LITLEN+1];

    if (attr == NULL)
	return FALSE;				/* Not found */
    else if (XmuCompareISOLatin1(attr->name, name) != 0)
	return get_attrib(self, attr->next, name, value, maxlen);
    else {
	i = j = 0;
	while (j < maxlen - 1 && attr->value[i]) {
	    if (attr->value[i] != '&')
		value[j++] = attr->value[i++];
	    else {
		i++;				/* Skip '&' */
		for (k = 0; isnmchar(attr->value[i+k]); k++) ;
		if (((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.get_entity(self, attr->value + i, k, s, sizeof(s), &dum)) {
		    i += k;
		    if (attr->value[i] == ';') i++;
		    for (k = 0; s[k] != '\0' && j < maxlen - 1; k++)
			value[j++] = s[k];
		} else {			/* Unknown entity, copy it */
		    value[j++] = '&';
		    for (; k > 0 && j < maxlen - 1; k--)
			value[j++] = attr->value[i++];
		}
	    }
	}
	value[j] = '\0';
	return TRUE;
    }
}
#line 37 "SSGML.w"
#line 50 "SSGML.w"
/*ARGSUSED*/
#if NeedFunctionPrototypes
#line 50 "SSGML.w"
void XfwfAddText(Widget self,const  char * text,Cardinal  nchars)
#else
#line 50 "SSGML.w"
void XfwfAddText(self,text,nchars)Widget self;const  char * text;Cardinal  nchars;
#endif
#line 51 "SSGML.w"
{
    if (! XtIsSubclass(self, xfwfSimpleSGMLWidgetClass))
	XtAppError(XtWidgetToApplicationContext(self),
		   "XfwfAddText called with incorrect widget");
    ((XfwfSimpleSGMLWidgetClass)self->core.widget_class)->xfwfSimpleSGML_class.add_text(self, text, nchars);
}
